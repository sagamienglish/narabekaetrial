<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>文法並べ替えマスター</title>
    <!-- Tailwind CSS (デザイン用) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM (アプリのエンジン) -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <!-- Babel (ブラウザでReactを動かす変換機) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- ★Mobile Drag & Drop Polyfill (iPad/スマホのタッチ操作をドラッグに変換) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mobile-drag-drop@2.3.0-rc.2/default.css">
    <script src="https://cdn.jsdelivr.net/npm/mobile-drag-drop@2.3.0-rc.2/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mobile-drag-drop@2.3.0-rc.2/scroll-behaviour.min.js"></script>

    <style>
        @keyframes bounce-slight {
            0%, 100% { transform: translateY(0) scale(0.9); }
            50% { transform: translateY(-5px) scale(0.9); }
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-bounce-slight { animation: bounce-slight 2s infinite; transform-origin: bottom left; }
        .animate-fadeIn { animation: fadeIn 0.5s ease-out; }
        .animate-slideUp { animation: slideUp 0.5s ease-out; }
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #f1f1f1; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #94a3b8; }

        /* ★ドラッグ中のカードのスタイル調整 */
        .dnd-drag-image-override {
            transform: scale(1.1) !important;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3) !important;
            opacity: 0.9 !important;
            z-index: 9999 !important;
            border: 2px solid #3B82F6 !important;
            background-color: white !important;
            border-radius: 0.5rem !important;
            pointer-events: none !important;
        }
        
        /* 選択中のカードスタイル */
        .card-selected {
            background-color: #FFF7ED !important; /* orange-50 */
            border-color: #F97316 !important; /* orange-500 */
            color: #C2410C !important; /* orange-700 */
            transform: scale(1.05);
            box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.3) !important;
        }

        /* 使用済みカードのスタイル */
        .card-used {
            opacity: 0.3 !important;
            background-color: #F1F5F9 !important; /* slate-100 */
            color: #94A3B8 !important; /* slate-400 */
            border-color: #E2E8F0 !important; /* slate-200 */
            box-shadow: none !important;
        }
    </style>
</head>
<body class="bg-slate-100 text-gray-800 font-sans">
    <div id="root"></div>

    <!-- ★Polyfillの初期化スクリプト -->
    <script>
        var options = {};
        if (window.MobileDragDrop && MobileDragDrop.scrollBehaviour) {
            options.dragImageTranslateOverride = MobileDragDrop.scrollBehaviour.dragImageTranslateOverride;
        }
        if (window.MobileDragDrop) {
            MobileDragDrop.polyfill(options);
        }
        window.addEventListener('touchmove', function() {}, {passive: false});
    </script>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- アイコンコンポーネント ---
        const IconBase = ({ children, size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {children}
            </svg>
        );

        const Play = (props) => <IconBase {...props}><polygon points="5 3 19 12 5 21 5 3"/></IconBase>;
        const RotateCcw = (props) => <IconBase {...props}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></IconBase>;
        const Volume2 = (props) => <IconBase {...props}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/></IconBase>;
        const Clock = (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></IconBase>;
        const Settings = (props) => <IconBase {...props}><path d="M12.22 2h-.44a2 2 0 0 1-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.18-.08a2 2 0 0 0-2 0l-.45.26a2 2 0 0 0-.67 2.65l.1.27a2 2 0 0 1-.36 1.83l-.29.17a2 2 0 0 0 0 3.46l.29.17a2 2 0 0 1 .36 1.83l-.1.27a2 2 0 0 0 .67 2.65l.45.26a2 2 0 0 0 2 0l.18-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 1 2 2h.44a2 2 0 0 1 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.18.08a2 2 0 0 0 2 0l.45-.26a2 2 0 0 0 .67-2.65l-.1-.27a2 2 0 0 1 .36-1.83l.29-.17a2 2 0 0 0 0-3.46l-.29-.17a2 2 0 0 1-.36-1.83l.1-.27a2 2 0 0 0-.67-2.65l-.45-.26a2 2 0 0 0-2 0l-.18.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 1-2-2z"/><circle cx="12" cy="12" r="3"/></IconBase>;
        const BookOpen = (props) => <IconBase {...props}><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></IconBase>;
        const AlertCircle = (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></IconBase>;
        const CheckCircle = (props) => <IconBase {...props}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></IconBase>;
        const HelpCircle = (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12.01" y2="17"/></IconBase>;
        const X = (props) => <IconBase {...props}><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></IconBase>;
        const Trophy = (props) => <IconBase {...props}><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M8 22v-4.66"/><path d="M16 22v-4.66"/><path d="M12 14.66a2 2 0 0 0-2 2v2"/><path d="M12 14.66a2 2 0 0 1 2 2v2"/><path d="M18 2l-1.6 8.59a7 7 0 0 1-8.8 0L6 2"/></IconBase>;
        const GripVertical = (props) => <IconBase {...props}><circle cx="9" cy="12" r="1"/><circle cx="9" cy="5" r="1"/><circle cx="9" cy="19" r="1"/><circle cx="15" cy="12" r="1"/><circle cx="15" cy="5" r="1"/><circle cx="15" cy="19" r="1"/></IconBase>;
        const ChevronRight = (props) => <IconBase {...props}><polyline points="9 18 15 12 9 6"/></IconBase>;
        const Flag = (props) => <IconBase {...props}><path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"/><line x1="4" y1="22" x2="4" y2="15"/></IconBase>;
        const Star = (props) => <IconBase {...props}><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></IconBase>;
        const Activity = (props) => <IconBase {...props}><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></IconBase>;
        const Calendar = (props) => <IconBase {...props}><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></IconBase>;
        const Save = (props) => <IconBase {...props}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></IconBase>;
        const Zap = (props) => <IconBase {...props}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></IconBase>;
        const Trash2 = (props) => <IconBase {...props}><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></IconBase>;
        const CheckSquare = (props) => <IconBase {...props}><polyline points="9 11 12 14 22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></IconBase>;
        const Square = (props) => <IconBase {...props}><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/></IconBase>;
        const Crown = (props) => <IconBase {...props}><path d="m2 4 3 12h14l3-12-6 7-4-7-4 7-6-7zm3 16h14"/></IconBase>;
        const Award = (props) => <IconBase {...props}><circle cx="12" cy="8" r="7"/><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"/></IconBase>;
        const Sprout = (props) => <IconBase {...props}><path d="M7 20h10"/><path d="M10 20c5.5-2.5.8-6.4 3-10"/><path d="M9.5 9.4c1.1.8 1.8 2.2 2.3 3.7-2 .4-3.2.4-4.8-.3-1.8-.9-2.3-2.7-1.9-4.6.3-1.3 1.3-2.6 3.2-3 2.1-.5 3.9.5 4.7 1.2Z"/></IconBase>;

        // --- 効果音 ---
        const playSound = (type) => {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain);
            gain.connect(ctx.destination);
            
            const now = ctx.currentTime;
            if (type === 'correct') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(523.25, now);
                osc.frequency.setValueAtTime(659.25, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                osc.start(now);
                osc.stop(now + 0.4);
            } else if (type === 'wrong') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'pop') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, now);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            }
        };

        // --- デフォルトデータ ---
        const DEFAULT_DATA_CSV = `
[I heard my parents talk about] my grades.	両親が私の成績について話しているのを聞いた。	知覚動詞	grades: 成績
[We saw a police officer chasing] a man.	私たちは警官が男の人を追いかけているのを見た。	知覚動詞	chase: 追いかける
I saw a boy scolded by his father.	私は少年が父親に叱られているのを見た。	知覚動詞	scold: 叱る (受動態に注意)
Didn’t you hear the phone ring?	電話が鳴るのが聞こえませんでしたか？	知覚動詞	ring: 鳴る
[I watched my favorite baseball player talk] about his team on YouTube.	私は好きな野球選手がYouTubeで自分のチームについて話しているのを見た。	知覚動詞	
Last Sunday, [I saw a deer surrounded by lions] on TV.	この前の日曜日、私はテレビでシカがライオンに囲まれているのを見た。	知覚動詞	surround: 囲む
My mother made me clean the bathroom.	母は私に浴室の掃除をさせた。	使役動詞	make O do: Oに(無理やり)～させる
[My mother let me play video games] last night.	母は昨夜、私にテレビゲームをさせてくれた。	使役動詞	let O do: Oに～させてあげる(許可)
My mother had the doctor look at her leg.	母は医者に足を診てもらった。	使役動詞	have O do: Oに～してもらう(依頼)
[My coach let me go home early] because I felt sick.	気分が悪かったので、コーチは私を早退させてくれた。	使役動詞	go home early: 早退する
The teacher made me clean the classroom by myself.	先生は私にひとりで教室の掃除をさせた。	使役動詞	by myself: ひとりで
At the hotel, [I had the staff carry my bag] to the room.	ホテルで、私はスタッフに部屋までカバンを運んでもらった。	使役動詞	
[My parents let me go to USJ] with my friends.	両親は私を友だちとUSJに行かせてくれた。	使役動詞	
[The comedian was made to drink Aojiru] as a penalty for the game.	その芸人はゲームの罰として青汁を飲まされた。	使役動詞	penalty: 罰 / makeの受動態はtoが必要
He asked me if I had seen the movie.	彼は私に、その映画を見たかどうか尋ねた。	接続詞	ask + O + if...: Oに～かどうか尋ねる
[My mother asked me when I would] come home.	母は私に、いつ帰ってくるのか尋ねた。	接続詞	
My friends [asked me if I wanted to play] e-sports.	友達は私にeスポーツをやりたいかどうか尋ねた。	接続詞	
Jane asked me what I was doing.	Janeは私に何をしているのか尋ねた。	接続詞	
[Some parents ask me if e-sports is] a real sport.	何人かの両親は私にeスポーツは本当のスポーツなのかどうか尋ねた。	接続詞	
[The e-sports player told us why he needed] mental skills.	eスポーツプレーヤ―たちは私たちになぜ精神的スキルが必要なのか伝えた。	接続詞	mental skills: 精神的な技術
He plays basketball [ as if he was ] a professional player.	彼はプロ選手であるかのようにプレーします。	仮定法	
The politician talks to us [ as if she knew ] everything.	その政治家は全てを知っているかのように私たちに話します。	仮定法	
The actor speaks English fluently [ as if he was ] a native speaker.	その俳優はネイティブスピーカーかのように流暢に英語を話します。	仮定法	fluently: 流暢に
I [ wish the weather was ] nice.	天気が良かったらなぁ。	仮定法	
I [ wish I could run fast].	速く走れたらなぁ。	仮定法	
If I [ lived in Hawaii, I would go ] surfing throughout the year.	もし早いに済んでいたら、一年中サーフィンに行くのに。	仮定法	
It takes two hours to get to school.  I [ wish the campus were closer ] to my house.	毎日２時間学校に行くのにかかる。キャンパスが家にもっと近かったらなぁ。	仮定法	
If I [ were rich, I would buy ] a house in Hawaii.	もし私が金持ちだったら、ハワイに家を買うだろうに。	仮定法	
If I [ had more money, I could ] buy a new smartphone.	もっとお金を持っていたら、新しいスマホを買えるのに。	仮定法	
What [ would you do if you were ] the president of the US?	あなたがアメリカ合衆国の大統領なら何をしますか。	仮定法	
`.trim();

        // 動詞リスト (knew, was 追加)
        const VERB_LIST = [
            "heard", "talk", "saw", "chasing", "scolded", "hear", "ring", "watched", 
            "surrounded", "made", "clean", "let", "play", "had", "look", "go", "felt", 
            "carry", "drink", "asked", "seen", "come", "wanted", "doing", "is", "told", "needed",
            "plays", "knows", "speaks", "wish", "could", "lived", "would", "takes", "were", "buy", "had", "knew", "was"
        ];

        // 結合対象の単語
        const PREFIX_WORDS = ['a', 'an', 'the', 'my', 'your', 'his', 'her', 'its', 'our', 'their', 'this', 'that', 'some', 'any'];

        // --- マスコットキャラクター: フクロウ先生 ---
        const MascotOwl = ({ emotion, message }) => {
            const formattedMessage = message ? message.split('\n').map((str, index) => (
                <React.Fragment key={index}>
                    {str}
                    {index !== message.split('\n').length - 1 && <br />}
                </React.Fragment>
            )) : null;

            return (
                <div className="relative flex items-center animate-bounce-slight transform scale-90 origin-bottom-left">
                    {/* Owl SVG */}
                    <svg width="70" height="70" viewBox="0 0 100 100" className="drop-shadow-md z-20">
                        <ellipse cx="50" cy="55" rx="35" ry="40" fill="#60A5FA" /> 
                        <ellipse cx="50" cy="65" rx="25" ry="28" fill="#FEF3C7" />
                        <path d="M25 30 L15 10 L40 25 Z" fill="#60A5FA" />
                        <path d="M75 30 L85 10 L60 25 Z" fill="#60A5FA" />
                        <circle cx="35" cy="45" r="12" fill="white" stroke="#2563EB" strokeWidth="2"/>
                        <circle cx="65" cy="45" r="12" fill="white" stroke="#2563EB" strokeWidth="2"/>
                        {emotion === 'happy' ? (
                        <>
                            <path d="M28 45 Q35 40 42 45" stroke="#2563EB" strokeWidth="3" fill="none" />
                            <path d="M58 45 Q65 40 72 45" stroke="#2563EB" strokeWidth="3" fill="none" />
                        </>
                        ) : emotion === 'sad' ? (
                        <>
                            <circle cx="35" cy="48" r="3" fill="#2563EB" />
                            <circle cx="65" cy="48" r="3" fill="#2563EB" />
                            <path d="M45 20 L30 25" stroke="white" strokeWidth="2" />
                        </>
                        ) : (
                        <>
                            <circle cx="35" cy="45" r="4" fill="#2563EB" />
                            <circle cx="65" cy="45" r="4" fill="#2563EB" />
                        </>
                        )}
                        <path d="M45 55 L55 55 L50 65 Z" fill="#F59E0B" />
                        <path d="M15 55 Q10 70 20 80" stroke="#3B82F6" strokeWidth="3" fill="none" />
                        <path d="M85 55 Q90 70 80 80" stroke="#3B82F6" strokeWidth="3" fill="none" />
                    </svg>
                    {/* 吹き出し */}
                    {formattedMessage && (
                        <div className="ml-3 bg-white border-2 border-blue-200 p-2 rounded-xl rounded-bl-none shadow-lg text-xs md:text-sm text-blue-900 font-bold min-w-[140px] max-w-[200px] z-20 animate-fadeIn leading-relaxed self-start mt-2">
                            {formattedMessage}
                        </div>
                    )}
                </div>
            );
        };

        // --- 円形タイマー ---
        const CircularTimer = ({ timeLeft, maxTime }) => {
            const radius = 16;
            const circumference = 2 * Math.PI * radius;
            const strokeDashoffset = circumference - (timeLeft / maxTime) * circumference;
            const colorClass = timeLeft < 10 ? "text-red-500" : "text-blue-500";

            return (
                <div className="relative w-12 h-12 flex items-center justify-center">
                    <svg className="w-full h-full transform -rotate-90">
                        <circle cx="24" cy="24" r={radius} stroke="currentColor" strokeWidth="3" fill="transparent" className="text-gray-200"/>
                        <circle cx="24" cy="24" r={radius} stroke="currentColor" strokeWidth="3" fill="transparent"
                        strokeDasharray={circumference} strokeDashoffset={strokeDashoffset} strokeLinecap="round"
                        className={`${colorClass} transition-all duration-1000 ease-linear`}
                        />
                    </svg>
                    <div className={`absolute text-xs font-bold ${colorClass}`}>{timeLeft}</div>
                </div>
            );
        };

        // --- Level Calculation System ---
        const getLevelInfo = (score) => {
            if (score >= 200) return { level: 10, title: "Grammar God", icon: <Crown size={48} className="text-yellow-500" />, color: "text-yellow-500" };
            if (score >= 180) return { level: 9, title: "Legend", icon: <Trophy size={48} className="text-purple-500" />, color: "text-purple-500" };
            if (score >= 160) return { level: 8, title: "Grandmaster", icon: <Award size={48} className="text-pink-500" />, color: "text-pink-500" };
            if (score >= 140) return { level: 7, title: "Master", icon: <Star size={48} className="text-red-500" />, color: "text-red-500" };
            if (score >= 120) return { level: 6, title: "Expert", icon: <Zap size={48} className="text-orange-500" />, color: "text-orange-500" };
            if (score >= 100) return { level: 5, title: "Professional", icon: <CheckCircle size={48} className="text-emerald-500" />, color: "text-emerald-500" };
            if (score >= 80) return { level: 4, title: "Advanced", icon: <BookOpen size={48} className="text-blue-500" />, color: "text-blue-500" };
            if (score >= 60) return { level: 3, title: "Intermediate", icon: <Activity size={48} className="text-cyan-500" />, color: "text-cyan-500" };
            if (score >= 40) return { level: 2, title: "Beginner", icon: <Sprout size={48} className="text-lime-500" />, color: "text-lime-500" };
            return { level: 1, title: "Novice", icon: <Sprout size={48} className="text-slate-400" />, color: "text-slate-400" };
        };

        // --- 学習履歴表示カード ---
        const StatsCard = ({ stats }) => {
            const levelInfo = getLevelInfo(stats.trialHighScore || 0);

            return (
                <div className="bg-white border border-gray-100 rounded-xl p-4 shadow-sm w-full max-w-sm animate-fadeIn">
                    <div className="flex items-center justify-between mb-3">
                        <div className="text-xs font-bold text-gray-500 uppercase tracking-wider flex items-center">
                            <Activity size={14} className="mr-1"/> Learning Stats
                        </div>
                    </div>
                    <div className="flex justify-around text-center divide-x divide-gray-100">
                        <div className="px-2 flex flex-col items-center">
                            <div className="text-2xl font-bold text-green-500">{stats.totalCorrect || 0}</div>
                            <div className="text-[10px] text-gray-500 flex items-center mt-1">
                                <CheckCircle size={10} className="mr-1"/> Total Correct
                            </div>
                        </div>
                        <div className="px-2 flex flex-col items-center">
                            <div className="text-2xl font-bold text-orange-500">{stats.trialHighScore || 0}</div>
                            <div className="text-[10px] text-gray-500 flex items-center mt-1">
                                <Trophy size={10} className="mr-1"/> High Score
                            </div>
                            <div className={`mt-1 text-[10px] font-bold ${levelInfo.color} bg-slate-50 px-1.5 rounded-full whitespace-nowrap`}>
                                {levelInfo.title} (Lv.{levelInfo.level})
                            </div>
                        </div>
                        <div className="px-2 flex flex-col items-center">
                            <div className="text-2xl font-bold text-blue-500">{(stats.learningGames || 0) + (stats.trialGames || 0)}</div>
                            <div className="text-[10px] text-gray-500 flex items-center mt-1">
                                <Play size={10} className="mr-1"/> Games
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const App = () => {
            // State
            const [allQuestions, setAllQuestions] = useState([]);
            const [playQuestions, setPlayQuestions] = useState([]);
            const [categories, setCategories] = useState([]);
            
            const [mode, setMode] = useState('menu'); 
            const [nextGameMode, setNextGameMode] = useState(null); 
            const [selectedCategorySet, setSelectedCategorySet] = useState(new Set()); 

            const [currentQIndex, setCurrentQIndex] = useState(0);
            
            // Game State (Learning Mode)
            const [shuffledWords, setShuffledWords] = useState([]);
            const [selectedWords, setSelectedWords] = useState([]);
            
            // Game State (Trial Mode) - 5問一括管理用
            const [trialState, setTrialState] = useState([]); 
            const [isTrialChecked, setIsTrialChecked] = useState(false); 

            const [draggedItem, setDraggedItem] = useState(null);
            const [selectedCardId, setSelectedCardId] = useState(null); 
            
            const [score, setScore] = useState(0); 
            const [correctCount, setCorrectCount] = useState(0); 
            const [questionStartTime, setQuestionStartTime] = useState(0); 
            
            const [timeLeft, setTimeLeft] = useState(120);
            const [maxTime, setMaxTime] = useState(120);
            const [isTimerActive, setIsTimerActive] = useState(false);
            
            const [mistakes, setMistakes] = useState([]);
            const [showJapanese, setShowJapanese] = useState(true);
            const [feedback, setFeedback] = useState(null);
            const [hintLevel, setHintLevel] = useState(0); 
            
            // Stats
            const [stats, setStats] = useState({ learningGames: 0, trialGames: 0, totalCorrect: 0, trialHighScore: 0 });

            // Settings
            const [rawCsvData, setRawCsvData] = useState(DEFAULT_DATA_CSV);
            
            // 初期化
            useEffect(() => {
                const savedStats = localStorage.getItem('grammarAppStats');
                if (savedStats) {
                    const parsed = JSON.parse(savedStats);
                    if (parsed.trialHighScore === undefined) {
                        setStats({
                            learningGames: parsed.learningGames || parsed.gamesPlayed || 0,
                            trialGames: parsed.trialGames || 0,
                            totalCorrect: parsed.totalScore || 0,
                            trialHighScore: 0
                        });
                    } else {
                        setStats(parsed);
                    }
                }

                const savedCsv = localStorage.getItem('grammarAppCsvData');
                const savedTime = localStorage.getItem('grammarAppTimeLimit');

                if (savedCsv) setRawCsvData(savedCsv);
                if (savedTime) setMaxTime(Number(savedTime));
            }, []);

            useEffect(() => {
                const { loaded, cats } = parseCSV(rawCsvData);
                setAllQuestions(loaded);
                setCategories(cats);
            }, [rawCsvData]);

            const saveSettings = () => {
                localStorage.setItem('grammarAppCsvData', rawCsvData);
                localStorage.setItem('grammarAppTimeLimit', maxTime);
                setMode('menu');
            };

            const clearStats = () => {
                if (confirm("学習履歴をすべてクリアしますか？")) {
                    localStorage.removeItem('grammarAppStats');
                    localStorage.removeItem('L10_grammar_highscore'); 
                    setStats({ learningGames: 0, trialGames: 0, totalCorrect: 0, trialHighScore: 0 });
                }
            };

            const updateStats = (finalCorrectCount, finalScore, gameMode) => {
                const newStats = { ...stats };
                
                if (gameMode === 'learning') {
                    newStats.learningGames = (newStats.learningGames || 0) + 1;
                } else if (gameMode === 'trial') {
                    newStats.trialGames = (newStats.trialGames || 0) + 1;
                    
                    if (finalScore > (newStats.trialHighScore || 0)) {
                        newStats.trialHighScore = finalScore;
                        
                        const levelInfo = getLevelInfo(finalScore);
                        const exportData = {
                            score: finalScore,
                            level: levelInfo.level,
                            title: levelInfo.title,
                            date: new Date().toISOString()
                        };
                        localStorage.setItem('L10_grammar_highscore', JSON.stringify(exportData));
                    }
                }
                
                newStats.totalCorrect = (newStats.totalCorrect || 0) + finalCorrectCount;
                
                setStats(newStats);
                localStorage.setItem('grammarAppStats', JSON.stringify(newStats));
            };

            const parseCSV = (csv) => {
                const cats = new Set();
                const loaded = csv.split('\n').map((line, index) => {
                    const parts = line.split('\t');
                    if (parts.length < 2) return null;
                    
                    const original = parts[0].trim();
                    let cleanOriginal = original;
                    let punctuation = "";
                    let preText = "";
                    let postText = "";

                    let coreText = original;
                    const match = original.match(/^(.*?)\[(.*?)\](.*?)$/);
                    
                    if (match) {
                        preText = match[1].trim();
                        coreText = match[2].trim();
                        postText = match[3].trim();
                    } else {
                        coreText = original;
                    }

                    if (coreText.match(/[.?!]$/)) {
                        punctuation = coreText.slice(-1);
                        coreText = coreText.slice(0, -1);
                    }

                    cleanOriginal = coreText; 

                    let words = cleanOriginal.split(/\s+/);
                    if (words.length > 0 && words[0] !== "I") {
                        words[0] = words[0].toLowerCase();
                    }

                    if (words.length >= 8) {
                        const groupedWords = [];
                        let i = 0;
                        while (i < words.length) {
                            const w = words[i];
                            const cleanW = w.toLowerCase().replace(/[^a-z]/g, '');
                            if (PREFIX_WORDS.includes(cleanW) && i + 1 < words.length) {
                                groupedWords.push(w + " " + words[i+1]);
                                i += 2;
                            } else {
                                groupedWords.push(w);
                                i++;
                            }
                        }
                        words = groupedWords;
                    }

                    const category = parts[2] ? parts[2].trim() : "一般";
                    const specificHint = parts[3] ? parts[3].trim() : "";
                    cats.add(category);

                    return {
                        id: index,
                        original: original,
                        cleanOriginal: cleanOriginal,
                        preText: preText,
                        postText: postText,
                        punctuation: punctuation,
                        japanese: parts[1] ? parts[1].trim() : "",
                        category: category,
                        specificHint: specificHint,
                        words: words
                    };
                }).filter(q => q !== null);

                return { loaded, cats: Array.from(cats) };
            };

            const goToCategorySelect = (targetMode) => {
                setNextGameMode(targetMode);
                setSelectedCategorySet(new Set()); 
                setMode('category_select');
            };

            const toggleCategory = (cat) => {
                const newSet = new Set(selectedCategorySet);
                if (newSet.has(cat)) {
                    newSet.delete(cat);
                } else {
                    newSet.add(cat);
                }
                setSelectedCategorySet(newSet);
            };

            const toggleAllCategories = () => {
                if (selectedCategorySet.size === categories.length) {
                    setSelectedCategorySet(new Set());
                } else {
                    setSelectedCategorySet(new Set(categories));
                }
            };

            const startGame = (gameMode, specificQList = null) => {
                let qList = [];
                
                if (gameMode === 'review') {
                    if (mistakes.length === 0) return alert("復習する問題がありません");
                    qList = [...mistakes];
                } else if (specificQList) {
                    qList = specificQList;
                } else {
                    if (selectedCategorySet.size === 0) {
                        return alert("カテゴリを1つ以上選択してください。");
                    }
                    let pool = allQuestions.filter(q => selectedCategorySet.has(q.category));
                    if (pool.length === 0) {
                        return alert("選択されたカテゴリの問題がありません。");
                    }
                    pool.sort(() => Math.random() - 0.5);
                    qList = pool.slice(0, 5); 
                }

                if (qList.length === 0) return alert("問題がありません");

                setPlayQuestions(qList);
                setCurrentQIndex(0);
                setScore(0);
                setCorrectCount(0);
                setFeedback(null);
                setHintLevel(0);
                
                if (gameMode !== 'review') setMistakes([]);
                
                setMode(gameMode);

                if (gameMode === 'trial') {
                    const initialTrialState = qList.map(q => {
                        const words = q.words.map((w, i) => ({ 
                            text: w, 
                            id: `q${q.id}-w${i}-${Math.random().toString(36).substr(2,5)}` 
                        })).sort(() => Math.random() - 0.5);
                        
                        return {
                            question: q,
                            selected: [],
                            bank: words,
                            status: 'playing' 
                        };
                    });
                    setTrialState(initialTrialState);
                    setIsTrialChecked(false);
                    setTimeLeft(maxTime);
                    setIsTimerActive(true);
                    setQuestionStartTime(Date.now()); 
                } else {
                    loadQuestion(qList[0]);
                    setIsTimerActive(false);
                }
            };

            const loadQuestion = (question) => {
                if (!question) return;
                setHintLevel(0);
                setFeedback(null);
                setSelectedWords([]);
                setSelectedCardId(null);
                setQuestionStartTime(Date.now()); 
                
                const words = question.words.map((w, i) => ({ 
                    text: w, 
                    id: `q${question.id}-w${i}-${Math.random().toString(36).substr(2,5)}` 
                }));
                setShuffledWords(words.sort(() => Math.random() - 0.5));
            };

            useEffect(() => {
                let timer;
                if (isTimerActive && timeLeft > 0 && mode === 'trial') {
                    timer = setInterval(() => setTimeLeft(p => p - 1), 1000);
                } else if (timeLeft === 0 && isTimerActive) {
                    setIsTimerActive(false);
                    checkTrialAnswers(); 
                }
                return () => clearInterval(timer);
            }, [isTimerActive, timeLeft, mode]);

            const finishGame = (finalScore = score, finalCorrectCount = correctCount) => {
                setIsTimerActive(false);
                setMode('result');
                if (mode === 'learning' || mode === 'trial') {
                    updateStats(finalCorrectCount, finalScore, mode);
                }
            };

            const handleDragStart = (e, word, fromBank, qIndex = -1) => {
                if (mode === 'learning' && (feedback === 'correct' || feedback === 'giveup')) return;
                if (mode === 'trial' && isTrialChecked) return;

                setDraggedItem({ word, fromBank, qIndex });
                e.dataTransfer.effectAllowed = "move";
                e.dataTransfer.setData("text/plain", JSON.stringify({word, fromBank}));
                e.target.style.opacity = '0.4';
                setSelectedCardId(null);
            };
            
            const handleDragEnd = (e) => {
                e.target.style.opacity = '1'; 
            };

            const handleDragOver = (e) => {
                e.preventDefault(); e.dataTransfer.dropEffect = "move";
            };

            const handleDrop = (e, targetArea, qIndex = -1) => {
                e.preventDefault();
                if (!draggedItem) return;
                
                if (mode === 'trial' && draggedItem.qIndex !== qIndex) return;

                if (mode === 'trial') {
                    handleTrialMoveWord(qIndex, draggedItem.word, draggedItem.fromBank, targetArea === 'answer');
                } else {
                    if (targetArea === 'answer') {
                        if (draggedItem.fromBank) moveWord(draggedItem.word, true);
                        else {
                            const newSelected = [...selectedWords];
                            const idx = newSelected.findIndex(w => w.id === draggedItem.word.id);
                            if (idx !== -1) {
                                const [removed] = newSelected.splice(idx, 1);
                                newSelected.push(removed);
                                setSelectedWords(newSelected);
                            }
                        }
                    } else if (targetArea === 'bank' && !draggedItem.fromBank) {
                        moveWord(draggedItem.word, false);
                    }
                }
                setDraggedItem(null);
            };

            const handleCardDrop = (e, targetWord, qIndex = -1) => {
                e.preventDefault();
                e.stopPropagation(); 
                if (!draggedItem) return;
                
                if (mode === 'trial' && draggedItem.qIndex !== qIndex) return;

                const draggedWord = draggedItem.word;

                if (mode === 'trial') {
                    handleTrialCardSwap(qIndex, draggedWord, targetWord, draggedItem.fromBank);
                } else {
                    if (!draggedItem.fromBank && selectedWords.some(w => w.id === targetWord.id)) {
                        const newSelected = [...selectedWords];
                        const dIdx = newSelected.findIndex(w => w.id === draggedWord.id);
                        const tIdx = newSelected.findIndex(w => w.id === targetWord.id);
                        if (dIdx !== -1 && tIdx !== -1) {
                            const [removed] = newSelected.splice(dIdx, 1);
                            newSelected.splice(tIdx, 0, removed);
                            setSelectedWords(newSelected);
                        }
                    } else if (draggedItem.fromBank && selectedWords.some(w => w.id === targetWord.id)) {
                        if (selectedWords.some(w => w.id === draggedWord.id)) return;
                        const newSelected = [...selectedWords];
                        const tIdx = newSelected.findIndex(w => w.id === targetWord.id);
                        newSelected.splice(tIdx, 0, draggedWord);
                        setSelectedWords(newSelected);
                    }
                }
                setDraggedItem(null);
            };

            const handleTrialMoveWord = (qIndex, word, fromBank, toAnswer) => {
                setTrialState(prev => {
                    const newState = [...prev];
                    const targetQ = newState[qIndex];
                    
                    if (toAnswer) {
                        if (!fromBank) {
                             const idx = targetQ.selected.findIndex(w => w.id === word.id);
                             if (idx !== -1) {
                                 const [removed] = targetQ.selected.splice(idx, 1);
                                 targetQ.selected.push(removed);
                             }
                        } else {
                             if (!targetQ.selected.some(w => w.id === word.id)) {
                                 targetQ.selected.push(word);
                             }
                        }
                    } else {
                        targetQ.selected = targetQ.selected.filter(w => w.id !== word.id);
                    }
                    return newState;
                });
            };

            const handleTrialCardSwap = (qIndex, draggedWord, targetWord, fromBank) => {
                setTrialState(prev => {
                    const newState = [...prev];
                    const targetQ = newState[qIndex];
                    
                    if (!fromBank) {
                        const dIdx = targetQ.selected.findIndex(w => w.id === draggedWord.id);
                        const tIdx = targetQ.selected.findIndex(w => w.id === targetWord.id);
                        if (dIdx !== -1 && tIdx !== -1) {
                            const [removed] = targetQ.selected.splice(dIdx, 1);
                            targetQ.selected.splice(tIdx, 0, removed);
                        }
                    } else {
                        if (!targetQ.selected.some(w => w.id === draggedWord.id)) {
                            const tIdx = targetQ.selected.findIndex(w => w.id === targetWord.id);
                            if (tIdx !== -1) {
                                targetQ.selected.splice(tIdx, 0, draggedWord);
                            } else {
                                targetQ.selected.push(draggedWord); 
                            }
                        }
                    }
                    return newState;
                });
            };

            const handleTrialSwapInPlace = (qIndex, id1, id2) => {
                setTrialState(prev => {
                    const newState = [...prev];
                    const targetQ = newState[qIndex];
                    const idx1 = targetQ.selected.findIndex(w => w.id === id1);
                    const idx2 = targetQ.selected.findIndex(w => w.id === id2);
                    
                    if (idx1 !== -1 && idx2 !== -1) {
                        [targetQ.selected[idx1], targetQ.selected[idx2]] = [targetQ.selected[idx2], targetQ.selected[idx1]];
                    }
                    return newState;
                });
            };

            const handleTrialWordClick = (qIndex, word, fromBank) => {
                if (isTrialChecked) return;
                playSound('pop');
                
                if (fromBank) {
                    const currentQState = trialState[qIndex];
                    const isUsed = currentQState.selected.some(w => w.id === word.id);
                    
                    if (isUsed) {
                        if (selectedCardId === word.id) {
                            handleTrialMoveWord(qIndex, word, false, false);
                            setSelectedCardId(null);
                        }
                    } else {
                        handleTrialMoveWord(qIndex, word, true, true);
                        setSelectedCardId(null);
                    }
                } else {
                    if (selectedCardId === null) {
                        setSelectedCardId(word.id);
                    } else if (selectedCardId === word.id) {
                        handleTrialMoveWord(qIndex, word, false, false);
                        setSelectedCardId(null);
                    } else {
                        const currentQState = trialState[qIndex];
                        const sourceWordInCurrent = currentQState.selected.find(w => w.id === selectedCardId);
                        
                        if (sourceWordInCurrent) {
                            handleTrialSwapInPlace(qIndex, selectedCardId, word.id);
                            setSelectedCardId(null);
                        } else {
                            setSelectedCardId(word.id);
                        }
                    }
                }
            };

            const checkTrialAnswers = () => {
                setIsTimerActive(false);
                setIsTrialChecked(true);
                
                let trialCorrectCount = 0;
                let newMistakes = [];

                const updatedState = trialState.map(item => {
                    const userSentence = item.selected.map(w => w.text).join(' ');
                    const isCorrect = userSentence.replace(/\s+/g, ' ').trim().toLowerCase() === item.question.cleanOriginal.replace(/\s+/g, ' ').trim().toLowerCase();
                    
                    let status = 'wrong';
                    if (isCorrect) {
                        status = 'correct';
                        trialCorrectCount++;
                    } else {
                        newMistakes.push(item.question);
                    }
                    return { ...item, status };
                });

                setTrialState(updatedState);
                setCorrectCount(trialCorrectCount);
                if (newMistakes.length > 0) {
                    setMistakes(prev => {
                        const ids = new Set(prev.map(m => m.id));
                        const added = newMistakes.filter(m => !ids.has(m.id));
                        return [...prev, ...added];
                    });
                }

                let totalScore = trialCorrectCount * 20;
                
                if (trialCorrectCount === 5) {
                    totalScore += timeLeft * 5;
                }
                
                setScore(totalScore);
                
                if (trialCorrectCount === 5) playSound('correct');
                else playSound('wrong');
                
                setTimeout(() => {
                    finishGame(totalScore, trialCorrectCount); 
                }, 4000); 
            };


            const handleWordClick = (word, fromBank) => {
                if (feedback === 'correct' || feedback === 'giveup') return;
                
                if (fromBank) {
                    const isUsed = selectedWords.some(w => w.id === word.id);
                    if (isUsed) {
                        if (selectedCardId === word.id) {
                             playSound('pop');
                             moveWord(word, false);
                             setSelectedCardId(null);
                        }
                    } else {
                        playSound('pop');
                        moveWord(word, true);
                        setSelectedCardId(null);
                    }
                } else {
                    playSound('pop');
                    if (selectedCardId === null) {
                        setSelectedCardId(word.id);
                    } else if (selectedCardId === word.id) {
                        moveWord(word, false);
                        setSelectedCardId(null);
                    } else {
                        swapSelectedWords(selectedCardId, word.id);
                        setSelectedCardId(null);
                    }
                }
            };

            const swapSelectedWords = (id1, id2) => {
                const newSelected = [...selectedWords];
                const index1 = newSelected.findIndex(w => w.id === id1);
                const index2 = newSelected.findIndex(w => w.id === id2);
                if (index1 !== -1 && index2 !== -1) {
                    [newSelected[index1], newSelected[index2]] = [newSelected[index2], newSelected[index1]];
                    setSelectedWords(newSelected);
                }
            };

            const moveWord = (word, fromBank) => {
                if (fromBank) {
                    if (!selectedWords.some(w => w.id === word.id)) {
                        setSelectedWords(prev => [...prev, word]);
                    }
                } else {
                    setSelectedWords(prev => prev.filter(w => w.id !== word.id));
                }
            };

            const calculateScorePoints = () => {
               return 0;
            };

            const checkAnswer = () => {
                const currentQ = playQuestions[currentQIndex];
                const userSentence = selectedWords.map(w => w.text).join(' ');
                const isCorrect = userSentence.replace(/\s+/g, ' ').trim().toLowerCase() === currentQ.cleanOriginal.replace(/\s+/g, ' ').trim().toLowerCase();

                if (isCorrect) {
                    handleCorrect();
                } else {
                    setFeedback('wrong');
                    playSound('wrong');
                    if (!mistakes.find(m => m.id === currentQ.id)) {
                        setMistakes(prev => [...prev, currentQ]);
                    }
                }
            };

            const handleCorrect = () => {
                const currentQ = playQuestions[currentQIndex];
                setFeedback('correct');
                playSound('correct');
                speakText(currentQ.original);
                setSelectedCardId(null); 
                setCorrectCount(prev => prev + 1);
                setScore(prev => prev + 1);
            };

            const handleGiveUp = () => {
                const currentQ = playQuestions[currentQIndex];
                setFeedback('giveup');
                playSound('wrong');
                speakText(currentQ.original);
                setSelectedCardId(null); 
                if (!mistakes.find(m => m.id === currentQ.id)) {
                    setMistakes(prev => [...prev, currentQ]);
                }
            };

            const nextQuestion = () => {
                if (currentQIndex + 1 < playQuestions.length) {
                    setCurrentQIndex(prev => prev + 1);
                    loadQuestion(playQuestions[currentQIndex + 1]);
                } else {
                    finishGame();
                }
            };

            const speakText = (text) => {
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.cancel();
                    const uttr = new SpeechSynthesisUtterance(text);
                    uttr.lang = 'en-US';
                    window.speechSynthesis.speak(uttr);
                }
            };

            const getOwlMessage = () => {
                const currentQ = playQuestions[currentQIndex];
                if (feedback === 'correct') {
                    if (mode === 'trial') return ""; 
                    return "Great Job!\nその調子！";
                }
                if (feedback === 'giveup') return "Don't worry.\n切り替えよう！";
                if (feedback === 'wrong') return "Oops!\n惜しい！";
                if (hintLevel === 1) return `動詞は\n"${getVerbHint()}" だよ！`;
                if (hintLevel === 2) return "文法や語句のヒント\nを見てみて！";
                return "";
            };

            const getOwlEmotion = () => {
                if (feedback === 'correct') return 'happy';
                if (feedback === 'wrong' || feedback === 'giveup') return 'sad';
                return 'neutral';
            };

            const isVerb = (text) => {
                const words = text.toLowerCase().replace(/[.,?]/g, '').split(/\s+/);
                return words.some(w => VERB_LIST.includes(w));
            };
            const getVerbHint = () => {
                const currentQ = playQuestions[currentQIndex];
                const verbs = currentQ.words.filter(w => isVerb(w));
                return verbs.join(", ");
            };
            const getGrammarHint = (cat) => {
                if (cat.includes('知覚')) return "知覚動詞(see/hear) + O + 原型/ing (Oが～するのを見る)";
                if (cat.includes('使役')) return "使役動詞(make/let) + O + 原型 (Oに～させる)";
                if (cat.includes('接続詞')) return "接続詞の後は [S + V] の語順になるよ！";
                if (cat.includes('仮定法')) return "I wish S Vp(過去) / as if S Vp / If S Vp, S would V";
                return "語順のルールを思い出して！";
            };

            const getCardStyle = (word, isSelectedArea, currentSelected = false) => {
                let style = "px-3 py-2 m-1 rounded bg-white border-2 border-gray-200 shadow-sm font-medium cursor-grab active:cursor-grabbing select-none transition-transform hover:scale-105 ";
                if (word.text.includes(' ')) style += "border-b-4 border-blue-100 ";
                
                if (isSelectedArea && currentSelected) {
                    style += " card-selected "; 
                }

                if (mode !== 'trial' && hintLevel >= 1 && isVerb(word.text) && !isSelectedArea) { 
                     style += " !font-bold !text-blue-700 !border-blue-400 !bg-blue-50 ring-2 ring-blue-200 ";
                }
                if (mode !== 'trial' && hintLevel >= 1 && isVerb(word.text) && isSelectedArea) {
                     style += " !font-bold !text-blue-700 !border-blue-400 ring-2 ring-blue-200 ";
                }

                return style;
            };

            // --- Render ---
            if (mode === 'menu') {
                return (
                    <div className="flex flex-col items-center justify-center h-full space-y-6 py-8 animate-fadeIn w-full">
                        <div className="text-center mb-4">
                            <h1 className="text-3xl font-extrabold text-blue-600 mb-2">文法並べ替えマスター</h1>
                            <div className="flex justify-center mb-2">
                                <MascotOwl emotion="happy" message="" />
                            </div>
                        </div>
                        <StatsCard stats={stats} />
                        <div className="w-full max-w-xs space-y-3">
                            <button onClick={() => goToCategorySelect('learning')} className="w-full flex items-center p-4 bg-white border-2 border-blue-100 rounded-xl shadow-sm hover:border-blue-500 transition-all group">
                                <div className="bg-blue-100 p-2 rounded-full mr-3 text-blue-600 group-hover:bg-blue-600 group-hover:text-white"><BookOpen size={20} /></div>
                                <div className="text-left"><div className="font-bold text-gray-800">学習モード</div><div className="text-xs text-gray-500">解説付きでじっくり</div></div>
                            </button>
                            <button onClick={() => goToCategorySelect('trial')} className="w-full flex items-center p-4 bg-white border-2 border-orange-100 rounded-xl shadow-sm hover:border-orange-500 transition-all group">
                                <div className="bg-orange-100 p-2 rounded-full mr-3 text-orange-600 group-hover:bg-orange-600 group-hover:text-white"><Clock size={20} /></div>
                                <div className="text-left"><div className="font-bold text-gray-800">タイムトライアル</div><div className="text-xs text-gray-500">スコアアタック</div></div>
                            </button>
                            {mistakes.length > 0 && (
                                <button onClick={() => startGame('review')} className="w-full flex items-center p-4 bg-white border-2 border-red-100 rounded-xl shadow-sm hover:border-red-500 transition-all group">
                                    <div className="bg-red-100 p-2 rounded-full mr-3 text-red-600 group-hover:bg-red-600 group-hover:text-white"><RotateCcw size={20} /></div>
                                    <div className="text-left"><div className="font-bold text-gray-800">復習モード</div><div className="text-xs text-gray-500">苦手な{mistakes.length}問を克服</div></div>
                                </button>
                            )}
                        </div>
                        <div className="flex items-center space-x-2 mt-4">
                            <button onClick={() => setMode('settings')} className="text-gray-400 hover:text-gray-600 flex items-center text-xs"><Settings size={14} className="mr-1" /> 教員用設定</button>
                            <button onClick={clearStats} className="text-gray-400 hover:text-red-500 flex items-center text-xs border-l pl-2 border-gray-300" title="学習履歴をクリア"><Trash2 size={14} className="mr-1" /> 履歴クリア</button>
                        </div>
                    </div>
                );
            }

            if (mode === 'category_select') {
                return (
                    <div className="flex flex-col h-full p-4 items-center">
                        <div className="flex items-center justify-between mb-4 w-full max-w-xl">
                            <button onClick={() => setMode('menu')} className="p-2 bg-gray-100 rounded-full hover:bg-gray-200"><X size={20}/></button>
                            <h2 className="text-lg font-bold text-gray-800">カテゴリ選択 ({nextGameMode === 'trial' ? 'Time Trial' : 'Learning'})</h2><div className="w-8"></div>
                        </div>
                        
                        <div className="flex-1 w-full max-w-md overflow-y-auto space-y-3 pb-4 custom-scrollbar pr-1">
                            {categories.map(cat => {
                                const isSelected = selectedCategorySet.has(cat);
                                return (
                                    <button 
                                        key={cat} 
                                        onClick={() => toggleCategory(cat)} 
                                        className={`w-full p-4 rounded-xl border-2 transition-all flex items-center justify-between ${isSelected ? 'border-blue-500 bg-blue-50 text-blue-800' : 'border-gray-200 bg-white text-gray-500 hover:border-blue-300'}`}
                                    >
                                        <span className="font-bold text-lg">{cat}</span>
                                        {isSelected ? <CheckSquare size={24} className="text-blue-500" /> : <Square size={24} className="text-gray-300" />}
                                    </button>
                                );
                            })}
                        </div>

                        <div className="w-full max-w-md flex justify-end mt-2 mb-4">
                             <button onClick={toggleAllCategories} className="text-sm text-blue-600 font-bold px-4 py-2 bg-blue-50 rounded-lg hover:bg-blue-100 transition-colors">
                                {selectedCategorySet.size === categories.length ? "全解除" : "すべて選択"}
                            </button>
                        </div>

                        <div className="w-full max-w-md pt-2 border-t border-gray-100">
                            <button 
                                onClick={() => startGame(nextGameMode)} 
                                disabled={selectedCategorySet.size === 0}
                                className={`w-full py-4 rounded-xl font-bold text-lg shadow-lg transition-all ${selectedCategorySet.size === 0 ? 'bg-gray-300 text-gray-500 cursor-not-allowed' : 'bg-blue-600 text-white hover:bg-blue-700 hover:scale-[1.02]'}`}
                            >
                                スタート
                            </button>
                        </div>
                    </div>
                );
            }

            if (mode === 'settings') {
                return (
                    <div className="p-4 max-w-xl mx-auto h-full flex flex-col">
                        <div className="flex items-center justify-between mb-4"><h2 className="text-lg font-bold flex items-center text-gray-800"><Settings className="mr-2"/> 設定</h2><button onClick={() => setMode('menu')} className="p-2 bg-gray-100 rounded-full hover:bg-gray-200"><X size={20}/></button></div>
                        <div className="mb-4 flex-1 flex flex-col">
                            <label className="block text-xs font-bold mb-1 text-gray-700">問題データ (CSV)</label>
                            <div className="text-xs text-gray-500 mb-2 bg-blue-50 p-2 rounded leading-tight">英文[TAB]日本語[TAB]カテゴリ[TAB]解説(省略可)<br/>※[ ]で囲むと並べ替え対象になります。例: Last Sunday, [I played]...<br/>※4列目に語句の解説などを入れるとヒント2で表示されます。</div>
                            <textarea value={rawCsvData} onChange={(e) => setRawCsvData(e.target.value)} className="flex-1 p-2 border border-gray-300 rounded-lg font-mono text-xs focus:ring-2 focus:ring-blue-500 outline-none resize-none"/>
                        </div>
                        <div className="mb-4"><label className="block text-xs font-bold mb-1 text-gray-700">制限時間(秒)</label><input type="number" value={maxTime} onChange={(e) => setMaxTime(Number(e.target.value))} className="p-2 border border-gray-300 rounded-lg w-24 text-center"/></div>
                        <button onClick={saveSettings} className="w-full py-3 bg-blue-600 text-white rounded-xl font-bold hover:bg-blue-700 flex items-center justify-center"><Save size={18} className="mr-2"/> 保存して戻る</button>
                    </div>
                );
            }
            
            if (mode === 'result') {
                 const levelInfo = getLevelInfo(score);
                 return (
                    <div className="flex flex-col items-center justify-center h-full text-center py-10 px-4 animate-fadeIn">
                        {mode === 'trial' || isTrialChecked ? (
                            <div className="flex flex-col items-center">
                                <div className="mb-2 relative">
                                    {levelInfo.icon}
                                    <div className={`text-xl font-black mt-2 ${levelInfo.color}`}>{levelInfo.title}</div>
                                    <div className="text-xs text-gray-400 font-bold uppercase tracking-widest mt-1">Level {levelInfo.level}</div>
                                </div>
                                
                                <h2 className="text-3xl font-extrabold text-gray-800 mb-2">
                                    {score} <span className="text-lg font-normal text-gray-500">pts</span>
                                </h2>
                                
                                <div className="text-sm text-gray-500 mb-6 bg-slate-50 px-4 py-2 rounded-lg">
                                    正解数: <span className="font-bold text-gray-800">{correctCount}</span> / {playQuestions.length}
                                    {correctCount === 5 && <span className="ml-2 text-green-600 font-bold text-xs">+Bonus!</span>}
                                </div>
                            </div>
                        ) : (
                            // Learning Mode Result
                            <div className="flex flex-col items-center mb-8">
                                <Trophy size={64} className="text-yellow-400 mb-4 drop-shadow-lg" />
                                <h2 className="text-2xl font-bold text-gray-800 mb-2">結果発表</h2>
                                <span className="text-4xl font-bold text-blue-600">{score} / {playQuestions.length} 問正解</span>
                            </div>
                        )}

                        {mistakes.length > 0 && (
                            <div className="w-full max-w-sm bg-red-50 border border-red-100 rounded-xl p-4 mb-6 text-left overflow-y-auto max-h-40">
                                <div className="font-bold text-red-800 mb-2 text-xs flex items-center"><AlertCircle size={14} className="mr-1"/> 要復習リスト</div>
                                <ul className="space-y-2">{mistakes.map((m, i) => (<li key={i} className="text-xs text-gray-700 bg-white p-2 rounded border border-red-100">{m.original}</li>))}</ul>
                            </div>
                        )}
                        <div className="flex space-x-3">
                            <button onClick={() => setMode('menu')} className="px-6 py-3 bg-white border border-gray-300 text-gray-600 rounded-xl font-bold hover:bg-gray-50">メニュー</button>
                            <button onClick={() => startGame(mode === 'trial' || isTrialChecked ? 'trial' : 'learning', Array.from(selectedCategorySet))} className="px-6 py-3 bg-blue-600 text-white rounded-xl font-bold hover:bg-blue-700 shadow-lg">もう一度</button>
                        </div>
                    </div>
                );
            }

            // --- Render: Trial Mode (List View) ---
            if (mode === 'trial') {
                return (
                    <div className="flex flex-col h-full max-w-4xl mx-auto px-4 py-4 relative">
                        <div className="flex justify-between items-center mb-2 px-2">
                            <button onClick={() => setMode('menu')} className="text-gray-400 hover:text-gray-700"><X size={24} /></button>
                            <div className="text-lg font-bold text-gray-700">Time Trial (5 Questions)</div>
                            <CircularTimer timeLeft={timeLeft} maxTime={maxTime} />
                        </div>

                        <div className="flex-1 overflow-y-auto custom-scrollbar pb-24">
                            {trialState.map((item, idx) => (
                                <div key={idx} className={`mb-8 p-4 rounded-2xl border-2 ${item.status === 'correct' ? 'bg-green-50 border-green-200' : item.status === 'wrong' ? 'bg-red-50 border-red-200' : 'bg-white border-blue-50'} transition-colors`}>
                                    <div className="mb-2 font-bold text-gray-600 text-sm flex justify-between">
                                        <span>Q{idx + 1}. {item.question.category}</span>
                                        {isTrialChecked && (
                                            <span className={item.status === 'correct' ? 'text-green-600' : 'text-red-600'}>
                                                {item.status === 'correct' ? 'Correct!' : 'Wrong'}
                                            </span>
                                        )}
                                    </div>
                                    <div className="mb-3 font-bold text-lg text-gray-800">{item.question.japanese}</div>
                                    
                                    {/* Answer Area */}
                                    <div 
                                        className={`min-h-[60px] rounded-xl p-2 flex flex-wrap items-center gap-2 border-2 border-dashed mb-3 ${isTrialChecked ? 'pointer-events-none opacity-80' : 'bg-slate-50 border-slate-300'}`}
                                        onDragOver={handleDragOver} 
                                        onDrop={(e) => handleDrop(e, 'answer', idx)}
                                    >
                                        {item.question.preText && <span className="font-bold text-gray-700 bg-gray-100 px-2 py-1 rounded">{item.question.preText}</span>}
                                        
                                        {item.selected.length === 0 && !isTrialChecked && <span className="text-gray-400 text-sm">Drag words here</span>}
                                        
                                        {item.selected.map((word) => (
                                            <div 
                                                key={word.id} 
                                                draggable={!isTrialChecked} 
                                                onDragStart={(e) => handleDragStart(e, word, false, idx)}
                                                onDragEnd={handleDragEnd}
                                                onDrop={(e) => handleCardDrop(e, word, idx)}
                                                onClick={() => handleTrialWordClick(idx, word, false)} 
                                                className={getCardStyle(word, true, selectedCardId === word.id)}
                                            >
                                                {word.text}
                                            </div>
                                        ))}

                                        {item.question.postText ? (
                                            <span className="font-bold text-gray-700 bg-gray-100 px-2 py-1 rounded">{item.question.postText}{item.question.punctuation}</span>
                                        ) : (
                                            item.question.punctuation && <span className="text-xl font-bold text-gray-800 self-center">{item.question.punctuation}</span>
                                        )}
                                    </div>

                                    {/* Bank Area */}
                                    {!isTrialChecked ? (
                                        <div className="flex flex-wrap gap-2 min-h-[40px]" onDragOver={handleDragOver} onDrop={(e) => handleDrop(e, 'bank', idx)}>
                                            {item.bank.map((word) => {
                                                const isUsed = item.selected.some(w => w.id === word.id);
                                                return (
                                                    <div 
                                                        key={word.id} 
                                                        draggable={!isUsed} 
                                                        onDragStart={(e) => !isUsed && handleDragStart(e, word, true, idx)} 
                                                        onDragEnd={handleDragEnd} 
                                                        onClick={() => !isUsed && handleTrialWordClick(idx, word, true)} 
                                                        className={`${getCardStyle(word, false)} ${isUsed ? 'card-used' : ''}`}
                                                    >
                                                        {word.text}
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    ) : (
                                        // Result Display after check
                                        <div className="text-sm bg-white p-3 rounded border border-gray-100">
                                            <div className="text-blue-900 font-serif mb-1">Answer: {item.question.original}</div>
                                            <div className="text-gray-500 text-xs">
                                                {getGrammarHint(item.question.category)}
                                                {item.question.specificHint && <span className="block mt-1 text-orange-500 font-bold">Memo: {item.question.specificHint}</span>}
                                            </div>
                                        </div>
                                    )}
                                </div>
                            ))}
                        </div>

                        {/* Footer Button */}
                        {!isTrialChecked && (
                            <div className="absolute bottom-4 left-0 right-0 px-4">
                                <button 
                                    onClick={checkTrialAnswers}
                                    className="w-full py-4 bg-orange-500 text-white rounded-xl font-bold text-xl shadow-lg hover:bg-orange-600 transition-all"
                                >
                                    Finish & Check!
                                </button>
                            </div>
                        )}
                        
                        {isTrialChecked && (
                            <div className="absolute bottom-4 left-0 right-0 px-4 animate-slideUp">
                                <button 
                                    onClick={() => finishGame()}
                                    className="w-full py-4 bg-blue-600 text-white rounded-xl font-bold text-xl shadow-lg hover:bg-blue-700 transition-all"
                                >
                                    See Results
                                </button>
                            </div>
                        )}
                    </div>
                );
            }

            // --- Render: Learning Mode (Original Single View) ---
            const currentQ = playQuestions[currentQIndex];
            if (!currentQ) return <div>Loading...</div>;

            return (
                <div className="flex flex-col h-full max-w-4xl mx-auto px-4 py-4 relative">
                    <div className="flex justify-between items-start mb-2">
                        <button onClick={() => setMode('menu')} className="text-gray-400 hover:text-gray-700"><X size={24} /></button>
                        <div className="flex flex-col items-center">
                            <div className="flex space-x-1 mb-1">
                                {playQuestions.map((_, idx) => (
                                    <div key={idx} className={`w-2 h-2 rounded-full ${idx === currentQIndex ? 'bg-blue-600' : 'bg-gray-200'}`}></div>
                                ))}
                            </div>
                            <span className="text-xs text-gray-400 font-bold">{currentQ.category}</span>
                        </div>
                        <div className="w-8"></div>
                    </div>

                    <div className="flex-1 flex flex-col justify-center min-h-0">
                        <div className="text-center mb-4">
                            <h2 className="text-xl md:text-2xl font-bold text-gray-800 leading-normal">{currentQ.japanese}</h2>
                        </div>
                        {(hintLevel > 0 && feedback !== 'correct') && (
                            <div className="mb-4 text-center animate-fadeIn z-30 relative flex flex-col items-center gap-2">
                                {hintLevel >= 1 && <div className="inline-block bg-yellow-50 border border-yellow-200 text-yellow-800 px-4 py-2 rounded-full text-sm font-bold shadow-sm"><span>💡 ヒント1: 動詞は 「<span className="text-blue-600">{getVerbHint()}</span>」 です！</span></div>}
                                {hintLevel >= 2 && <div className="inline-block bg-orange-50 border border-orange-200 text-orange-800 px-4 py-2 rounded-full text-sm font-bold shadow-sm max-w-md"><div className="mb-1">📘 ヒント2: {getGrammarHint(currentQ.category)}</div>{currentQ.specificHint && <div className="border-t border-orange-200 pt-1 mt-1 text-xs text-orange-900 bg-orange-100 p-2 rounded"><span className="font-bold">Memo:</span> {currentQ.specificHint}</div>}</div>}
                            </div>
                        )}
                        <div className="space-y-6">
                            {/* Answer Area */}
                            <div 
                                className={`min-h-[80px] rounded-xl p-3 flex flex-wrap items-center justify-center gap-2 border-2 border-dashed transition-colors ${feedback === 'correct' ? 'bg-green-50 border-green-300 border-solid' : 'bg-slate-50 border-slate-300'}`}
                                onDragOver={handleDragOver} onDrop={(e) => handleDrop(e, 'answer')}
                            >
                                {/* 固定語句（前） */}
                                {currentQ.preText && (
                                    <span className="font-bold text-gray-700 bg-gray-100 px-2 py-1 rounded mr-1">{currentQ.preText}</span>
                                )}

                                {selectedWords.length === 0 && <div className="text-gray-400 text-sm pointer-events-none flex items-center"><GripVertical size={16} className="mr-1 opacity-50"/> 単語を並べてください</div>}
                                {selectedWords.map((word) => (
                                    <div 
                                        key={word.id} 
                                        draggable={!feedback} 
                                        onDragStart={(e) => handleDragStart(e, word, false)}
                                        onDragEnd={handleDragEnd} 
                                        onDrop={(e) => handleCardDrop(e, word)}
                                        onClick={() => handleWordClick(word, false)} 
                                        className={getCardStyle(word, true, selectedCardId === word.id)}
                                    >
                                        {word.text}
                                    </div>
                                ))}

                                {/* 固定語句（後）or 文末記号 */}
                                {currentQ.postText ? (
                                    <span className="font-bold text-gray-700 bg-gray-100 px-2 py-1 rounded ml-1">{currentQ.postText}{currentQ.punctuation}</span>
                                ) : (
                                    currentQ.punctuation && <div className="text-xl font-bold text-gray-800 self-center pt-1">{currentQ.punctuation}</div>
                                )}
                            </div>

                            {/* Word Bank */}
                            <div className="flex flex-wrap justify-center gap-2 min-h-[60px]" onDragOver={handleDragOver} onDrop={(e) => handleDrop(e, 'bank')}>
                                {shuffledWords.map((word) => {
                                    const isUsed = selectedWords.some(w => w.id === word.id);
                                    return (
                                        <div 
                                            key={word.id} 
                                            draggable={!isUsed && !feedback} 
                                            onDragStart={(e) => !isUsed && handleDragStart(e, word, true)} 
                                            onDragEnd={handleDragEnd} 
                                            onClick={() => handleWordClick(word, true)} 
                                            className={`${getCardStyle(word, false)} ${isUsed ? 'card-used' : ''}`}
                                        >
                                            {word.text}
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    </div>

                    <div className="mt-auto pt-4 relative">
                        <div className="absolute left-0 bottom-16 hidden md:block pointer-events-none z-0"><MascotOwl emotion={getOwlEmotion()} message={getOwlMessage()} /></div>
                        {feedback === 'correct' || feedback === 'giveup' ? (
                            <div className="bg-white border-2 border-blue-100 shadow-xl rounded-2xl p-4 animate-slideUp z-10 relative">
                                <div className="flex items-center justify-between mb-2">
                                    <div className={`flex items-center font-bold text-lg ${feedback==='correct' ? 'text-green-700' : 'text-gray-600'}`}>{feedback==='correct' ? <CheckCircle className="mr-2"/> : <Flag className="mr-2"/>}{feedback==='correct' ? 'Correct!' : 'Answer'}</div>
                                    <button onClick={() => speakText(currentQ.original)} className="p-2 bg-gray-100 rounded-full hover:bg-blue-100 hover:text-blue-600"><Volume2 size={20} /></button>
                                </div>
                                <div className="text-lg text-blue-900 font-serif bg-blue-50 p-2 rounded mb-3">{currentQ.original}</div>
                                <div className="text-sm text-gray-600 mb-4 bg-white border border-gray-100 p-2 rounded">
                                    <span className="font-bold text-blue-600 block mb-1">★解説: {currentQ.category}</span> 
                                    {getGrammarHint(currentQ.category)}
                                    {currentQ.specificHint && <div className="mt-2 pt-2 border-t border-gray-100 text-xs text-gray-500"><span className="font-bold">Memo:</span> {currentQ.specificHint}</div>}
                                </div>
                                <button onClick={nextQuestion} className="w-full py-3 bg-blue-600 text-white rounded-xl font-bold hover:bg-blue-700 shadow-md">次へ進む</button>
                            </div>
                        ) : (
                            <div className="space-y-3 z-10 relative bg-white/80 md:bg-transparent p-2 rounded-xl backdrop-blur-sm md:backdrop-blur-none">
                                <div className="flex gap-2 animate-fadeIn pl-0 md:pl-56"> 
                                    <button onClick={() => setHintLevel(1)} disabled={hintLevel >= 1} className="flex-1 py-2 bg-yellow-50 text-yellow-800 border border-yellow-200 rounded-lg text-xs font-bold hover:bg-yellow-100 disabled:opacity-50 transition-colors"><HelpCircle size={14} className="inline mr-1"/> ヒント1:動詞</button>
                                    <button onClick={() => setHintLevel(2)} disabled={hintLevel < 1 || hintLevel >= 2} className="flex-1 py-2 bg-orange-50 text-orange-800 border border-orange-200 rounded-lg text-xs font-bold hover:bg-orange-100 disabled:opacity-50 transition-colors"><BookOpen size={14} className="inline mr-1"/> ヒント2:文法+</button>
                                </div>
                                <div className="flex gap-2 pl-0 md:pl-56">
                                    <button onClick={handleGiveUp} className="px-4 py-3 bg-gray-200 text-gray-600 rounded-xl font-bold hover:bg-gray-300 text-sm whitespace-nowrap">Give up</button>
                                    <button onClick={checkAnswer} disabled={selectedWords.length !== currentQ.words.length} className={`flex-1 py-3 rounded-xl font-bold shadow-md transition-all text-lg ${selectedWords.length !== currentQ.words.length ? 'bg-gray-300 text-gray-500 cursor-not-allowed' : 'bg-blue-600 text-white hover:bg-blue-700 hover:scale-[1.02]'}`}>Check</button>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>

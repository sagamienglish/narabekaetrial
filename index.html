import React, { useState, useEffect, useRef } from 'react';
import { Play, RotateCcw, Volume2, Clock, Settings, BookOpen, AlertCircle, CheckCircle, HelpCircle, X, Trophy, GripVertical, ChevronRight, Flag, Star, Activity, Calendar, Save, Zap } from 'lucide-react';

// --- éŸ³å£°ãƒ‡ãƒ¼ã‚¿ (Base64 placeholder) ---
const SOUND_CORRECT = "data:audio/mp3;base64,//NExAAAAania..."; 
const SOUND_WRONG = "data:audio/mp3;base64,//NExAAAAania...";   

// åŠ¹æœéŸ³å†ç”Ÿ
const playSound = (type) => {
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.connect(gain);
  gain.connect(ctx.destination);
  
  const now = ctx.currentTime;
  if (type === 'correct') {
    osc.type = 'sine';
    osc.frequency.setValueAtTime(523.25, now); // C5
    osc.frequency.setValueAtTime(659.25, now + 0.1); // E5
    gain.gain.setValueAtTime(0.1, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
    osc.start(now);
    osc.stop(now + 0.4);
  } else if (type === 'wrong') {
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(150, now);
    gain.gain.setValueAtTime(0.1, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
    osc.start(now);
    osc.stop(now + 0.3);
  } else if (type === 'pop') {
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(400, now);
    gain.gain.setValueAtTime(0.05, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
    osc.start(now);
    osc.stop(now + 0.1);
  }
};

// --- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ‡ãƒ¼ã‚¿ ---
const DEFAULT_DATA_CSV = `
I heard my parents talk about my grades.	ä¸¡è¦ªãŒç§ã®æˆç¸¾ã«ã¤ã„ã¦è©±ã—ã¦ã„ã‚‹ã®ã‚’èã„ãŸã€‚	çŸ¥è¦šå‹•è©	grades: æˆç¸¾
We saw a police officer chasing a man.	ç§ãŸã¡ã¯è­¦å®˜ãŒç”·ã®äººã‚’è¿½ã„ã‹ã‘ã¦ã„ã‚‹ã®ã‚’è¦‹ãŸã€‚	çŸ¥è¦šå‹•è©	chase: è¿½ã„ã‹ã‘ã‚‹
I saw a boy scolded by his father.	ç§ã¯å°‘å¹´ãŒçˆ¶è¦ªã«å±ã‚‰ã‚Œã¦ã„ã‚‹ã®ã‚’è¦‹ãŸã€‚	çŸ¥è¦šå‹•è©	scold: å±ã‚‹ (å—å‹•æ…‹ã«æ³¨æ„)
Didnâ€™t you hear the phone ring?	é›»è©±ãŒé³´ã‚‹ã®ãŒèã“ãˆã¾ã›ã‚“ã§ã—ãŸã‹ï¼Ÿ	çŸ¥è¦šå‹•è©	ring: é³´ã‚‹
I watched my favorite baseball player talk about his team on YouTube.	ç§ã¯å¥½ããªé‡çƒé¸æ‰‹ãŒYouTubeã§è‡ªåˆ†ã®ãƒãƒ¼ãƒ ã«ã¤ã„ã¦è©±ã—ã¦ã„ã‚‹ã®ã‚’è¦‹ãŸã€‚	çŸ¥è¦šå‹•è©
I saw a deer surrounded by lions on TV.	ç§ã¯ãƒ†ãƒ¬ãƒ“ã§ã€ã‚·ã‚«ãŒãƒ©ã‚¤ã‚ªãƒ³ã«å›²ã¾ã‚Œã¦ã„ã‚‹ã®ã‚’è¦‹ãŸã€‚	çŸ¥è¦šå‹•è©	surround: å›²ã‚€ / deer: ã‚·ã‚«(å˜è¤‡åŒå½¢)
My mother made me clean the bathroom.	æ¯ã¯ç§ã«ï¼ˆè¨€ã„ã¤ã‘ã¦ï¼‰æµ´å®¤ã®æƒé™¤ã‚’ã•ã›ãŸã€‚	ä½¿å½¹å‹•è©	make O do: Oã«(ç„¡ç†ã‚„ã‚Š)ï½ã•ã›ã‚‹
My mother let me play video games last night.	æ¯ã¯æ˜¨å¤œã€ç§ã«ãƒ†ãƒ¬ãƒ“ã‚²ãƒ¼ãƒ ã‚’ã•ã›ã¦ãã‚ŒãŸã€‚	ä½¿å½¹å‹•è©	let O do: Oã«ï½ã•ã›ã¦ã‚ã’ã‚‹(è¨±å¯)
My mother had the doctor look at her leg.	æ¯ã¯åŒ»è€…ã«è¶³ã‚’è¨ºã¦ã‚‚ã‚‰ã£ãŸã€‚	ä½¿å½¹å‹•è©	have O do: Oã«ï½ã—ã¦ã‚‚ã‚‰ã†(ä¾é ¼)
My coach let me go home early because I felt sick.	æ°—åˆ†ãŒæ‚ªã‹ã£ãŸã®ã§ã€ã‚³ãƒ¼ãƒã¯ç§ã‚’æ—©é€€ã•ã›ã¦ãã‚ŒãŸã€‚	ä½¿å½¹å‹•è©	go home early: æ—©é€€ã™ã‚‹
The teacher made me clean the classroom by myself.	å…ˆç”Ÿã¯ç§ã«ã²ã¨ã‚Šã§æ•™å®¤ã®æƒé™¤ã‚’ã•ã›ãŸã€‚	ä½¿å½¹å‹•è©	by myself: ã²ã¨ã‚Šã§
At the hotel, I had the staff carry my bag to the room.	ãƒ›ãƒ†ãƒ«ã§ã€ç§ã¯ã‚¹ã‚¿ãƒƒãƒ•ã«éƒ¨å±‹ã¾ã§ã‚«ãƒãƒ³ã‚’é‹ã‚“ã§ã‚‚ã‚‰ã£ãŸã€‚	ä½¿å½¹å‹•è©
My parents let me go to USJ with my friends.	ä¸¡è¦ªã¯ç§ã‚’å‹ã ã¡ã¨USJã«è¡Œã‹ã›ã¦ãã‚ŒãŸã€‚	ä½¿å½¹å‹•è©
The comedian was made to drink Aojiru as a penalty for the game.	ãã®èŠ¸äººã¯ã‚²ãƒ¼ãƒ ã®ç½°ã¨ã—ã¦é’æ±ã‚’é£²ã¾ã•ã‚ŒãŸã€‚	ä½¿å½¹å‹•è©	penalty: ç½° / makeã®å—å‹•æ…‹ã¯toãŒå¿…è¦
He asked me if I had seen the movie.	å½¼ã¯ç§ã«ã€ãã®æ˜ ç”»ã‚’è¦‹ãŸã‹ã©ã†ã‹å°‹ã­ãŸã€‚	æ¥ç¶šè©	ask + O + if...: Oã«ï½ã‹ã©ã†ã‹å°‹ã­ã‚‹
My mother asked me when I would come home.	æ¯ã¯ç§ã«ã€ã„ã¤å¸°ã£ã¦ãã‚‹ã®ã‹å°‹ã­ãŸã€‚	æ¥ç¶šè©
My friends asked me if I wanted to play e-sports.	å‹é”ã¯ç§ã«eã‚¹ãƒãƒ¼ãƒ„ã‚’ã‚„ã‚ŠãŸã„ã‹ã©ã†ã‹å°‹ã­ãŸã€‚	æ¥ç¶šè©
Jane asked me what I was doing.	Janeã¯ç§ã«ä½•ã‚’ã—ã¦ã„ã‚‹ã®ã‹å°‹ã­ãŸã€‚	æ¥ç¶šè©
Some parents ask me if e-sports is a real sport.	ä½•äººã‹ã®ä¸¡è¦ªã¯ç§ã«eã‚¹ãƒãƒ¼ãƒ„ã¯æœ¬å½“ã®ã‚¹ãƒãƒ¼ãƒ„ãªã®ã‹ã©ã†ã‹å°‹ã­ãŸã€‚	æ¥ç¶šè©
The e-sports player told us why he needed mental skills.	eã‚¹ãƒãƒ¼ãƒ„ãƒ—ãƒ¬ãƒ¼ãƒ¤â€•ãŸã¡ã¯ç§ãŸã¡ã«ãªãœç²¾ç¥çš„ã‚¹ã‚­ãƒ«ãŒå¿…è¦ãªã®ã‹ä¼ãˆãŸã€‚	æ¥ç¶šè©	mental skills: ç²¾ç¥çš„ãªæŠ€è¡“
`.trim();

// å‹•è©ãƒªã‚¹ãƒˆ
const VERB_LIST = [
  "heard", "talk", "saw", "chasing", "scolded", "hear", "ring", "watched", 
  "surrounded", "made", "clean", "let", "play", "had", "look", "go", "felt", 
  "carry", "drink", "asked", "seen", "come", "wanted", "doing", "is", "told", "needed"
];

// çµåˆå¯¾è±¡ã®å˜èª
const PREFIX_WORDS = ['a', 'an', 'the', 'my', 'your', 'his', 'her', 'its', 'our', 'their', 'this', 'that', 'some', 'any'];

// --- ãƒã‚¹ã‚³ãƒƒãƒˆã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼: ãƒ•ã‚¯ãƒ­ã‚¦å…ˆç”Ÿ ---
const MascotOwl = ({ emotion, message }) => {
  const formattedMessage = message ? message.split('\n').map((str, index) => (
    <React.Fragment key={index}>
      {str}
      {index !== message.split('\n').length - 1 && <br />}
    </React.Fragment>
  )) : null;

  return (
    <div className="relative flex items-center animate-bounce-slight transform scale-90 origin-bottom-left">
      {/* Owl SVG */}
      <svg width="70" height="70" viewBox="0 0 100 100" className="drop-shadow-md z-20">
        <ellipse cx="50" cy="55" rx="35" ry="40" fill="#60A5FA" /> 
        <ellipse cx="50" cy="65" rx="25" ry="28" fill="#FEF3C7" />
        <path d="M25 30 L15 10 L40 25 Z" fill="#60A5FA" />
        <path d="M75 30 L85 10 L60 25 Z" fill="#60A5FA" />
        <circle cx="35" cy="45" r="12" fill="white" stroke="#2563EB" strokeWidth="2"/>
        <circle cx="65" cy="45" r="12" fill="white" stroke="#2563EB" strokeWidth="2"/>
        {emotion === 'happy' ? (
          <>
             <path d="M28 45 Q35 40 42 45" stroke="#2563EB" strokeWidth="3" fill="none" />
             <path d="M58 45 Q65 40 72 45" stroke="#2563EB" strokeWidth="3" fill="none" />
          </>
        ) : emotion === 'sad' ? (
          <>
             <circle cx="35" cy="48" r="3" fill="#2563EB" />
             <circle cx="65" cy="48" r="3" fill="#2563EB" />
             <path d="M45 20 L30 25" stroke="white" strokeWidth="2" />
          </>
        ) : (
          <>
             <circle cx="35" cy="45" r="4" fill="#2563EB" />
             <circle cx="65" cy="45" r="4" fill="#2563EB" />
          </>
        )}
        <path d="M45 55 L55 55 L50 65 Z" fill="#F59E0B" />
        <path d="M15 55 Q10 70 20 80" stroke="#3B82F6" strokeWidth="3" fill="none" />
        <path d="M85 55 Q90 70 80 80" stroke="#3B82F6" strokeWidth="3" fill="none" />
      </svg>
      {/* å¹ãå‡ºã— */}
      {formattedMessage && (
        <div className="ml-3 bg-white border-2 border-blue-200 p-2 rounded-xl rounded-bl-none shadow-lg text-xs md:text-sm text-blue-900 font-bold min-w-[140px] max-w-[200px] z-20 animate-fadeIn leading-relaxed self-start mt-2">
          {formattedMessage}
        </div>
      )}
    </div>
  );
};

// --- å††å½¢ã‚¿ã‚¤ãƒãƒ¼ ---
const CircularTimer = ({ timeLeft, maxTime }) => {
  const radius = 16;
  const circumference = 2 * Math.PI * radius;
  const strokeDashoffset = circumference - (timeLeft / maxTime) * circumference;
  const colorClass = timeLeft < 10 ? "text-red-500" : "text-blue-500";

  return (
    <div className="relative w-12 h-12 flex items-center justify-center">
      <svg className="w-full h-full transform -rotate-90">
        <circle cx="24" cy="24" r={radius} stroke="currentColor" strokeWidth="3" fill="transparent" className="text-gray-200"/>
        <circle cx="24" cy="24" r={radius} stroke="currentColor" strokeWidth="3" fill="transparent"
          strokeDasharray={circumference} strokeDashoffset={strokeDashoffset} strokeLinecap="round"
          className={`${colorClass} transition-all duration-1000 ease-linear`}
        />
      </svg>
      <div className={`absolute text-xs font-bold ${colorClass}`}>{timeLeft}</div>
    </div>
  );
};

// --- å­¦ç¿’å±¥æ­´è¡¨ç¤ºã‚«ãƒ¼ãƒ‰ ---
const StatsCard = ({ stats }) => (
  <div className="bg-white border border-gray-100 rounded-xl p-4 shadow-sm w-full max-w-sm animate-fadeIn">
    <div className="flex items-center justify-between mb-3">
      <div className="text-xs font-bold text-gray-500 uppercase tracking-wider flex items-center">
        <Activity size={14} className="mr-1"/> Learning Stats
      </div>
    </div>
    <div className="flex justify-around text-center divide-x divide-gray-100">
      <div className="px-2 flex flex-col items-center">
        <div className="text-2xl font-bold text-green-500">{stats.totalCorrect || 0}</div>
        <div className="text-[10px] text-gray-500 flex items-center mt-1">
          <CheckCircle size={10} className="mr-1"/> Total Correct
        </div>
      </div>
      <div className="px-2 flex flex-col items-center">
        <div className="text-2xl font-bold text-orange-500">{stats.trialHighScore || 0}</div>
        <div className="text-[10px] text-gray-500 flex items-center mt-1">
          <Trophy size={10} className="mr-1"/> High Score
        </div>
      </div>
      <div className="px-2 flex flex-col items-center">
        <div className="text-2xl font-bold text-blue-500">{(stats.learningGames || 0) + (stats.trialGames || 0)}</div>
        <div className="text-[10px] text-gray-500 flex items-center mt-1">
          <Play size={10} className="mr-1"/> Games
        </div>
      </div>
    </div>
  </div>
);

const App = () => {
  // State
  const [allQuestions, setAllQuestions] = useState([]);
  const [playQuestions, setPlayQuestions] = useState([]);
  const [categories, setCategories] = useState([]);
  
  const [mode, setMode] = useState('menu');
  const [currentQIndex, setCurrentQIndex] = useState(0);
  
  // Game State
  const [shuffledWords, setShuffledWords] = useState([]);
  const [selectedWords, setSelectedWords] = useState([]);
  const [draggedItem, setDraggedItem] = useState(null);
  
  const [score, setScore] = useState(0); // Trial: Points, Learning: Correct Count (Display Only logic)
  const [correctCount, setCorrectCount] = useState(0); // æ­£è§£æ•°ã‚«ã‚¦ãƒ³ãƒˆç”¨
  const [questionStartTime, setQuestionStartTime] = useState(0); // å›ç­”é–‹å§‹æ™‚åˆ»
  
  const [timeLeft, setTimeLeft] = useState(60);
  const [maxTime, setMaxTime] = useState(60);
  const [isTimerActive, setIsTimerActive] = useState(false);
  
  const [mistakes, setMistakes] = useState([]);
  const [showJapanese, setShowJapanese] = useState(true);
  const [feedback, setFeedback] = useState(null);
  const [hintLevel, setHintLevel] = useState(0); 
  
  // Stats
  const [stats, setStats] = useState({ learningGames: 0, trialGames: 0, totalCorrect: 0, trialHighScore: 0 });

  // Settings
  const [rawCsvData, setRawCsvData] = useState(DEFAULT_DATA_CSV);
  
  // åˆæœŸåŒ–ï¼šãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
  useEffect(() => {
    // Stats
    const savedStats = localStorage.getItem('grammarAppStats');
    if (savedStats) {
      const parsed = JSON.parse(savedStats);
      // å¤ã„ãƒ‡ãƒ¼ã‚¿ã®ç§»è¡Œå‡¦ç†
      if (parsed.trialHighScore === undefined) {
         setStats({
           learningGames: parsed.learningGames || parsed.gamesPlayed || 0,
           trialGames: parsed.trialGames || 0,
           totalCorrect: parsed.totalScore || 0, // ä»¥å‰ã®totalScoreã¯æ­£è§£æ•°ã¨ã—ã¦æ‰±ã†
           trialHighScore: 0
         });
      } else {
         setStats(parsed);
      }
    }

    // Settings
    const savedCsv = localStorage.getItem('grammarAppCsvData');
    const savedTime = localStorage.getItem('grammarAppTimeLimit');

    if (savedCsv) setRawCsvData(savedCsv);
    if (savedTime) setMaxTime(Number(savedTime));
  }, []);

  // CSVãŒå¤‰ã‚ã£ãŸã‚‰ãƒ‘ãƒ¼ã‚¹
  useEffect(() => {
    const { loaded, cats } = parseCSV(rawCsvData);
    setAllQuestions(loaded);
    setCategories(cats);
  }, [rawCsvData]);

  const saveSettings = () => {
    localStorage.setItem('grammarAppCsvData', rawCsvData);
    localStorage.setItem('grammarAppTimeLimit', maxTime);
    setMode('menu');
  };

  const updateStats = (finalCorrectCount, finalScore, gameMode) => {
    const newStats = { ...stats };
    
    if (gameMode === 'learning') {
      newStats.learningGames = (newStats.learningGames || 0) + 1;
    } else if (gameMode === 'trial') {
      newStats.trialGames = (newStats.trialGames || 0) + 1;
      // High Scoreæ›´æ–°
      if (finalScore > (newStats.trialHighScore || 0)) {
        newStats.trialHighScore = finalScore;
      }
    }
    
    newStats.totalCorrect = (newStats.totalCorrect || 0) + finalCorrectCount;
    
    setStats(newStats);
    localStorage.setItem('grammarAppStats', JSON.stringify(newStats));
  };

  const parseCSV = (csv) => {
    const cats = new Set();
    const loaded = csv.split('\n').map((line, index) => {
      const parts = line.split('\t');
      if (parts.length < 2) return null;
      
      const original = parts[0].trim();
      let cleanOriginal = original;
      let punctuation = "";

      if (original.match(/[.?!]$/)) {
        punctuation = original.slice(-1);
        cleanOriginal = original.slice(0, -1);
      }

      let words = cleanOriginal.split(/\s+/);
      if (words.length > 0 && words[0] !== "I") {
        words[0] = words[0].toLowerCase();
      }

      if (words.length >= 8) {
        const groupedWords = [];
        let i = 0;
        while (i < words.length) {
          const w = words[i];
          const cleanW = w.toLowerCase().replace(/[^a-z]/g, '');
          if (PREFIX_WORDS.includes(cleanW) && i + 1 < words.length) {
            groupedWords.push(w + " " + words[i+1]);
            i += 2;
          } else {
            groupedWords.push(w);
            i++;
          }
        }
        words = groupedWords;
      }

      const category = parts[2] ? parts[2].trim() : "ä¸€èˆ¬";
      const specificHint = parts[3] ? parts[3].trim() : "";
      cats.add(category);

      return {
        id: index,
        original: original,
        cleanOriginal: cleanOriginal,
        punctuation: punctuation,
        japanese: parts[1] ? parts[1].trim() : "",
        category: category,
        specificHint: specificHint,
        words: words
      };
    }).filter(q => q !== null);

    return { loaded, cats: Array.from(cats) };
  };

  // --- ã‚²ãƒ¼ãƒ é–‹å§‹ ---
  const startGame = (gameMode, category = null) => {
    let qList = [];
    if (gameMode === 'review') {
      if (mistakes.length === 0) return alert("å¾©ç¿’ã™ã‚‹å•é¡ŒãŒã‚ã‚Šã¾ã›ã‚“");
      qList = [...mistakes];
    } else {
      let pool = [...allQuestions];
      if (category && category !== 'ALL') {
        pool = pool.filter(q => q.category === category);
      }
      pool.sort(() => Math.random() - 0.5);
      qList = pool.slice(0, 5); 
    }

    if (qList.length === 0) return alert("å•é¡ŒãŒã‚ã‚Šã¾ã›ã‚“");

    setPlayQuestions(qList);
    setCurrentQIndex(0);
    setScore(0);
    setCorrectCount(0);
    if (gameMode !== 'review') setMistakes([]);
    
    loadQuestion(qList[0]);

    if (gameMode === 'trial') {
      setTimeLeft(maxTime);
      setIsTimerActive(true);
      setMode('trial');
    } else {
      setIsTimerActive(false);
      setMode('learning');
    }
  };

  const loadQuestion = (question) => {
    if (!question) return;
    setHintLevel(0);
    setFeedback(null);
    setSelectedWords([]);
    setQuestionStartTime(Date.now()); // æ™‚é–“è¨ˆæ¸¬é–‹å§‹
    
    const words = question.words.map((w, i) => ({ 
      text: w, 
      id: `q${question.id}-w${i}-${Math.random().toString(36).substr(2,5)}` 
    }));
    setShuffledWords(words.sort(() => Math.random() - 0.5));
  };

  // --- ã‚¿ã‚¤ãƒãƒ¼ ---
  useEffect(() => {
    let timer;
    if (isTimerActive && timeLeft > 0 && mode === 'trial') {
      timer = setInterval(() => setTimeLeft(p => p - 1), 1000);
    } else if (timeLeft === 0 && isTimerActive) {
      setIsTimerActive(false);
      finishGame();
    }
    return () => clearInterval(timer);
  }, [isTimerActive, timeLeft, mode]);

  const finishGame = () => {
    setIsTimerActive(false);
    setMode('result');
    if (mode === 'learning' || mode === 'trial') {
        updateStats(correctCount, score, mode);
    }
  };

  // --- Drag & Drop ---
  const handleDragStart = (e, word, fromBank) => {
    if (feedback === 'correct' || feedback === 'giveup') return;
    setDraggedItem({ word, fromBank });
    e.dataTransfer.effectAllowed = "move";
  };

  const handleDragOver = (e) => {
    e.preventDefault(); e.dataTransfer.dropEffect = "move";
  };

  const handleDrop = (e, targetArea) => {
    e.preventDefault();
    if (!draggedItem) return;
    if (draggedItem.fromBank && targetArea === 'answer') {
      moveWord(draggedItem.word, true);
    } else if (!draggedItem.fromBank && targetArea === 'bank') {
      moveWord(draggedItem.word, false);
    }
    setDraggedItem(null);
  };

  const handleWordClick = (word, fromBank) => {
    if (feedback === 'correct' || feedback === 'giveup') return;
    playSound('pop');
    moveWord(word, fromBank);
  };

  const moveWord = (word, fromBank) => {
    if (fromBank) {
      setShuffledWords(prev => prev.filter(w => w.id !== word.id));
      setSelectedWords(prev => [...prev, word]);
    } else {
      setSelectedWords(prev => prev.filter(w => w.id !== word.id));
      setShuffledWords(prev => [...prev, word]);
    }
  };

  // --- åˆ¤å®šãƒ»ã‚¹ã‚³ã‚¢è¨ˆç®— ---
  const calculateScorePoints = () => {
    // åŸºæº–ç‚¹
    const basePoints = 1000;
    // æ™‚é–“æ¸›ç‚¹: 1ç§’ã”ã¨ã«10ç‚¹æ¸›ç‚¹ (æœ€ä½0ç‚¹ã¾ã§)
    const duration = (Date.now() - questionStartTime) / 1000;
    const timePenalty = Math.floor(duration) * 10;
    // ãƒ’ãƒ³ãƒˆæ¸›ç‚¹: Lv1=-300, Lv2=-600 (ç´¯ç©ã§ã¯ãªããƒ¬ãƒ™ãƒ«ã§åˆ¤å®š)
    const hintPenalty = hintLevel * 300;
    
    let p = basePoints - timePenalty - hintPenalty;
    if (p < 100) p = 100; // æœ€ä½ç‚¹ä¿è¨¼(æ­£è§£ã™ã‚Œã°å¿…ãšã‚‚ã‚‰ãˆã‚‹)
    return p;
  };

  const checkAnswer = () => {
    const currentQ = playQuestions[currentQIndex];
    const userSentence = selectedWords.map(w => w.text).join(' ');
    const isCorrect = userSentence.replace(/\s+/g, ' ').trim().toLowerCase() === currentQ.cleanOriginal.replace(/\s+/g, ' ').trim().toLowerCase();

    if (isCorrect) {
      handleCorrect();
    } else {
      setFeedback('wrong');
      playSound('wrong');
      if (!mistakes.find(m => m.id === currentQ.id)) {
        setMistakes(prev => [...prev, currentQ]);
      }
    }
  };

  const handleCorrect = () => {
    const currentQ = playQuestions[currentQIndex];
    setFeedback('correct');
    playSound('correct');
    speakText(currentQ.original);
    
    // ã‚¹ã‚³ã‚¢/æ­£è§£æ•°åŠ ç®—
    setCorrectCount(prev => prev + 1);
    
    if (mode === 'trial') {
      const points = calculateScorePoints();
      setScore(prev => prev + points);
    } else {
      setScore(prev => prev + 1); // Learningãƒ¢ãƒ¼ãƒ‰ã¯æ­£è§£æ•°è¡¨ç¤º
    }
  };

  const handleGiveUp = () => {
    const currentQ = playQuestions[currentQIndex];
    setFeedback('giveup');
    playSound('wrong');
    speakText(currentQ.original);
    if (!mistakes.find(m => m.id === currentQ.id)) {
      setMistakes(prev => [...prev, currentQ]);
    }
  };

  const nextQuestion = () => {
    if (currentQIndex + 1 < playQuestions.length) {
      setCurrentQIndex(prev => prev + 1);
      loadQuestion(playQuestions[currentQIndex + 1]);
    } else {
      finishGame();
    }
  };

  const speakText = (text) => {
    if ('speechSynthesis' in window) {
      window.speechSynthesis.cancel();
      const uttr = new SpeechSynthesisUtterance(text);
      uttr.lang = 'en-US';
      window.speechSynthesis.speak(uttr);
    }
  };

  // --- ãƒã‚¹ã‚³ãƒƒãƒˆãƒ»ãƒ’ãƒ³ãƒˆ ---
  const getOwlMessage = () => {
    const currentQ = playQuestions[currentQIndex];
    if (feedback === 'correct') {
      if (mode === 'trial') return `Nice!\n+${calculateScorePoints()}pts`; // æ­£è§£æ™‚ã¯ç‚¹æ•°ã‚’è¡¨ç¤º(å†è¨ˆç®—ã«ãªã‚‹ãŒè¿‘ä¼¼å€¤ã§OK)
      return "Great Job!\nãã®èª¿å­ï¼";
    }
    if (feedback === 'giveup') return "Don't worry.\nåˆ‡ã‚Šæ›¿ãˆã‚ˆã†ï¼";
    if (feedback === 'wrong') return "Oops!\næƒœã—ã„ï¼";
    if (hintLevel === 1) return `å‹•è©ã¯\n"${getVerbHint()}" ã ã‚ˆï¼`;
    if (hintLevel === 2) return "æ–‡æ³•ã‚„èªå¥ã®ãƒ’ãƒ³ãƒˆ\nã‚’è¦‹ã¦ã¿ã¦ï¼";
    return "";
  };

  const getOwlEmotion = () => {
    if (feedback === 'correct') return 'happy';
    if (feedback === 'wrong' || feedback === 'giveup') return 'sad';
    return 'neutral';
  };

  const isVerb = (text) => {
    const firstWord = text.split(' ')[0].toLowerCase().replace(/[.,?]/g, '');
    return VERB_LIST.includes(firstWord);
  };
  const getVerbHint = () => {
    const currentQ = playQuestions[currentQIndex];
    const verbs = currentQ.words.filter(w => isVerb(w));
    return verbs.join(", ");
  };
  const getGrammarHint = (cat) => {
    if (cat.includes('çŸ¥è¦š')) return "çŸ¥è¦šå‹•è©(see/hear) + O + åŸå‹/ing (OãŒï½ã™ã‚‹ã®ã‚’è¦‹ã‚‹)";
    if (cat.includes('ä½¿å½¹')) return "ä½¿å½¹å‹•è©(make/let) + O + åŸå‹ (Oã«ï½ã•ã›ã‚‹)";
    if (cat.includes('æ¥ç¶šè©')) return "æ¥ç¶šè©ã®å¾Œã¯ [S + V] ã®èªé †ã«ãªã‚‹ã‚ˆï¼";
    return "èªé †ã®ãƒ«ãƒ¼ãƒ«ã‚’æ€ã„å‡ºã—ã¦ï¼";
  };

  // --- Render ---
  const getCardStyle = (word, isSelectedArea) => {
    let style = "px-3 py-2 m-1 rounded bg-white border-2 border-gray-200 shadow-sm font-medium cursor-grab active:cursor-grabbing select-none transition-transform hover:scale-105 ";
    if (word.text.includes(' ')) style += "border-b-4 border-blue-100 ";
    if (hintLevel >= 1 && isVerb(word.text)) style += " !font-bold !text-blue-700 !border-blue-400 !bg-blue-50 ring-2 ring-blue-200 ";
    return style;
  };

  const renderMenu = () => (
    <div className="flex flex-col items-center justify-center h-full space-y-6 py-8 animate-fadeIn w-full">
      <div className="text-center mb-4">
        <h1 className="text-3xl font-extrabold text-blue-600 mb-2">æ–‡æ³•ä¸¦ã¹æ›¿ãˆãƒã‚¹ã‚¿ãƒ¼</h1>
        <div className="flex justify-center mb-2">
           <MascotOwl emotion="happy" message="" />
        </div>
      </div>
      <StatsCard stats={stats} />
      <div className="w-full max-w-xs space-y-3">
        <button onClick={() => setMode('category_select')} 
          className="w-full flex items-center p-4 bg-white border-2 border-blue-100 rounded-xl shadow-sm hover:border-blue-500 transition-all group">
          <div className="bg-blue-100 p-2 rounded-full mr-3 text-blue-600 group-hover:bg-blue-600 group-hover:text-white"><BookOpen size={20} /></div>
          <div className="text-left"><div className="font-bold text-gray-800">å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰</div><div className="text-xs text-gray-500">è§£èª¬ä»˜ãã§ã˜ã£ãã‚Š</div></div>
        </button>
        <button onClick={() => startGame('trial')}
          className="w-full flex items-center p-4 bg-white border-2 border-orange-100 rounded-xl shadow-sm hover:border-orange-500 transition-all group">
          <div className="bg-orange-100 p-2 rounded-full mr-3 text-orange-600 group-hover:bg-orange-600 group-hover:text-white"><Clock size={20} /></div>
          <div className="text-left"><div className="font-bold text-gray-800">ã‚¿ã‚¤ãƒ ãƒˆãƒ©ã‚¤ã‚¢ãƒ«</div><div className="text-xs text-gray-500">ã‚¹ã‚³ã‚¢ã‚¢ã‚¿ãƒƒã‚¯</div></div>
        </button>
        {mistakes.length > 0 && (
          <button onClick={() => startGame('review')}
            className="w-full flex items-center p-4 bg-white border-2 border-red-100 rounded-xl shadow-sm hover:border-red-500 transition-all group">
            <div className="bg-red-100 p-2 rounded-full mr-3 text-red-600 group-hover:bg-red-600 group-hover:text-white"><RotateCcw size={20} /></div>
            <div className="text-left"><div className="font-bold text-gray-800">å¾©ç¿’ãƒ¢ãƒ¼ãƒ‰</div><div className="text-xs text-gray-500">è‹¦æ‰‹ãª{mistakes.length}å•ã‚’å…‹æœ</div></div>
          </button>
        )}
      </div>
      <button onClick={() => setMode('settings')} className="text-gray-400 hover:text-gray-600 flex items-center text-xs mt-4"><Settings size={14} className="mr-1" /> æ•™å“¡ç”¨è¨­å®š</button>
    </div>
  );

  const renderGame = () => {
    const currentQ = playQuestions[currentQIndex];
    if (!currentQ) return <div>Loading...</div>;

    return (
      <div className="flex flex-col h-full max-w-4xl mx-auto px-4 py-4 relative">
        <div className="flex justify-between items-start mb-2">
          <button onClick={() => setMode('menu')} className="text-gray-400 hover:text-gray-700"><X size={24} /></button>
          <div className="flex flex-col items-center">
             <div className="flex space-x-1 mb-1">
               {playQuestions.map((_, idx) => (
                 <div key={idx} className={`w-2 h-2 rounded-full ${idx === currentQIndex ? 'bg-blue-600' : 'bg-gray-200'}`}></div>
               ))}
             </div>
             {mode === 'trial' ? (
                <span className="text-lg font-bold text-orange-500">Score: {score}</span>
             ) : (
                <span className="text-xs text-gray-400 font-bold">{currentQ.category}</span>
             )}
          </div>
          {mode === 'trial' ? <CircularTimer timeLeft={timeLeft} maxTime={maxTime} /> : <div className="w-8"></div>}
        </div>

        <div className="flex-1 flex flex-col justify-center min-h-0">
          <div className="text-center mb-4">
             <h2 className="text-xl md:text-2xl font-bold text-gray-800 leading-normal">{currentQ.japanese}</h2>
          </div>
          {(hintLevel > 0 && feedback !== 'correct') && (
            <div className="mb-4 text-center animate-fadeIn z-30 relative flex flex-col items-center gap-2">
                {hintLevel >= 1 && <div className="inline-block bg-yellow-50 border border-yellow-200 text-yellow-800 px-4 py-2 rounded-full text-sm font-bold shadow-sm"><span>ğŸ’¡ ãƒ’ãƒ³ãƒˆ1: å‹•è©ã¯ ã€Œ<span className="text-blue-600">{getVerbHint()}</span>ã€ ã§ã™ï¼</span></div>}
                {hintLevel >= 2 && <div className="inline-block bg-orange-50 border border-orange-200 text-orange-800 px-4 py-2 rounded-full text-sm font-bold shadow-sm max-w-md"><div className="mb-1">ğŸ“˜ ãƒ’ãƒ³ãƒˆ2: {getGrammarHint(currentQ.category)}</div>{currentQ.specificHint && <div className="border-t border-orange-200 pt-1 mt-1 text-xs text-orange-900 bg-orange-100 p-2 rounded"><span className="font-bold">Memo:</span> {currentQ.specificHint}</div>}</div>}
            </div>
          )}
          <div className="space-y-6">
            <div 
              className={`min-h-[80px] rounded-xl p-3 flex flex-wrap items-center justify-center gap-2 border-2 border-dashed transition-colors ${feedback === 'correct' ? 'bg-green-50 border-green-300 border-solid' : 'bg-slate-50 border-slate-300'}`}
              onDragOver={handleDragOver} onDrop={(e) => handleDrop(e, 'answer')}
            >
              {selectedWords.length === 0 && <div className="text-gray-400 text-sm pointer-events-none flex items-center"><GripVertical size={16} className="mr-1 opacity-50"/> å˜èªã‚’ä¸¦ã¹ã¦ãã ã•ã„</div>}
              {selectedWords.map((word) => (
                <div key={word.id} draggable={!feedback} onDragStart={(e) => handleDragStart(e, word, false)} onClick={() => handleWordClick(word, false)} className={getCardStyle(word, true)}>{word.text}</div>
              ))}
              {currentQ.punctuation && <div className="text-xl font-bold text-gray-800 self-center pt-1">{currentQ.punctuation}</div>}
            </div>
            <div className="flex flex-wrap justify-center gap-2 min-h-[60px]" onDragOver={handleDragOver} onDrop={(e) => handleDrop(e, 'bank')}>
              {shuffledWords.map((word) => (
                <div key={word.id} draggable={!feedback} onDragStart={(e) => handleDragStart(e, word, true)} onClick={() => handleWordClick(word, true)} className={getCardStyle(word, false)}>{word.text}</div>
              ))}
            </div>
          </div>
        </div>

        <div className="mt-auto pt-4 relative">
          <div className="absolute left-0 bottom-16 hidden md:block pointer-events-none z-0"><MascotOwl emotion={getOwlEmotion()} message={getOwlMessage()} /></div>
          {feedback === 'correct' || feedback === 'giveup' ? (
             <div className="bg-white border-2 border-blue-100 shadow-xl rounded-2xl p-4 animate-slideUp z-10 relative">
               <div className="flex items-center justify-between mb-2">
                 <div className={`flex items-center font-bold text-lg ${feedback==='correct' ? 'text-green-700' : 'text-gray-600'}`}>{feedback==='correct' ? <CheckCircle className="mr-2"/> : <Flag className="mr-2"/>}{feedback==='correct' ? 'Correct!' : 'Answer'}</div>
                 <button onClick={() => speakText(currentQ.original)} className="p-2 bg-gray-100 rounded-full hover:bg-blue-100 hover:text-blue-600"><Volume2 size={20} /></button>
               </div>
               <div className="text-lg text-blue-900 font-serif bg-blue-50 p-2 rounded mb-3">{currentQ.original}</div>
               <div className="text-sm text-gray-600 mb-4 bg-white border border-gray-100 p-2 rounded">
                 <span className="font-bold text-blue-600 block mb-1">â˜…è§£èª¬: {currentQ.category}</span> 
                 {getGrammarHint(currentQ.category)}
                 {currentQ.specificHint && <div className="mt-2 pt-2 border-t border-gray-100 text-xs text-gray-500"><span className="font-bold">Memo:</span> {currentQ.specificHint}</div>}
               </div>
               <button onClick={nextQuestion} className="w-full py-3 bg-blue-600 text-white rounded-xl font-bold hover:bg-blue-700 shadow-md">æ¬¡ã¸é€²ã‚€</button>
             </div>
          ) : (
             <div className="space-y-3 z-10 relative bg-white/80 md:bg-transparent p-2 rounded-xl backdrop-blur-sm md:backdrop-blur-none">
                <div className="flex gap-2 animate-fadeIn pl-0 md:pl-56"> 
                  <button onClick={() => setHintLevel(1)} disabled={hintLevel >= 1} className="flex-1 py-2 bg-yellow-50 text-yellow-800 border border-yellow-200 rounded-lg text-xs font-bold hover:bg-yellow-100 disabled:opacity-50 transition-colors"><HelpCircle size={14} className="inline mr-1"/> ãƒ’ãƒ³ãƒˆ1:å‹•è©</button>
                  <button onClick={() => setHintLevel(2)} disabled={hintLevel < 1 || hintLevel >= 2} className="flex-1 py-2 bg-orange-50 text-orange-800 border border-orange-200 rounded-lg text-xs font-bold hover:bg-orange-100 disabled:opacity-50 transition-colors"><BookOpen size={14} className="inline mr-1"/> ãƒ’ãƒ³ãƒˆ2:æ–‡æ³•+</button>
                </div>
                <div className="flex gap-2 pl-0 md:pl-56">
                  <button onClick={handleGiveUp} className="px-4 py-3 bg-gray-200 text-gray-600 rounded-xl font-bold hover:bg-gray-300 text-sm whitespace-nowrap">Give up</button>
                  <button onClick={checkAnswer} disabled={selectedWords.length !== currentQ.words.length} className={`flex-1 py-3 rounded-xl font-bold shadow-md transition-all text-lg ${selectedWords.length !== currentQ.words.length ? 'bg-gray-300 text-gray-500 cursor-not-allowed' : 'bg-blue-600 text-white hover:bg-blue-700 hover:scale-[1.02]'}`}>Check</button>
                </div>
             </div>
          )}
        </div>
      </div>
    );
  };

  const renderResult = () => (
    <div className="flex flex-col items-center justify-center h-full text-center py-10 px-4 animate-fadeIn">
      <Trophy size={64} className="text-yellow-400 mb-4 drop-shadow-lg" />
      <h2 className="text-2xl font-bold text-gray-800 mb-2">çµæœç™ºè¡¨</h2>
      <div className="mb-6">
         {mode === 'trial' ? (
            <div className="flex flex-col items-center">
               <span className="text-gray-500 text-sm">TOTAL SCORE</span>
               <span className="text-5xl font-extrabold text-orange-500">{score}</span>
               <span className="text-gray-400 text-sm mt-1">({correctCount} / {playQuestions.length} å•æ­£è§£)</span>
            </div>
         ) : (
            <span className="text-4xl font-bold text-blue-600">{score} / {playQuestions.length} å•æ­£è§£</span>
         )}
      </div>
      {mistakes.length > 0 && (
        <div className="w-full max-w-sm bg-red-50 border border-red-100 rounded-xl p-4 mb-6 text-left overflow-y-auto max-h-40">
          <div className="font-bold text-red-800 mb-2 text-xs flex items-center"><AlertCircle size={14} className="mr-1"/> è¦å¾©ç¿’ãƒªã‚¹ãƒˆ</div>
          <ul className="space-y-2">{mistakes.map((m, i) => (<li key={i} className="text-xs text-gray-700 bg-white p-2 rounded border border-red-100">{m.original}</li>))}</ul>
        </div>
      )}
      <div className="flex space-x-3">
        <button onClick={() => setMode('menu')} className="px-6 py-3 bg-white border border-gray-300 text-gray-600 rounded-xl font-bold hover:bg-gray-50">ãƒ¡ãƒ‹ãƒ¥ãƒ¼</button>
        <button onClick={() => startGame(mode === 'trial' ? 'trial' : 'learning', 'ALL')} className="px-6 py-3 bg-blue-600 text-white rounded-xl font-bold hover:bg-blue-700 shadow-lg">ã‚‚ã†ä¸€åº¦</button>
      </div>
    </div>
  );

  const renderCategorySelect = () => (
      <div className="flex flex-col h-full py-4 px-4">
        <div className="flex items-center justify-between mb-4">
          <button onClick={() => setMode('menu')} className="p-2 bg-gray-100 rounded-full hover:bg-gray-200"><X size={20}/></button>
          <h2 className="text-lg font-bold text-gray-800">ã‚«ãƒ†ã‚´ãƒªé¸æŠ</h2><div className="w-8"></div>
        </div>
        <div className="flex-1 overflow-y-auto grid grid-cols-2 gap-3 pb-4 max-w-2xl mx-auto w-full">
          <button onClick={() => startGame('learning', 'ALL')} className="p-3 rounded-lg border-2 border-blue-100 bg-blue-50 text-blue-800 font-bold hover:bg-blue-100 text-sm text-center col-span-2">ã™ã¹ã¦ (ãƒ©ãƒ³ãƒ€ãƒ )</button>
          {categories.map(cat => (<button key={cat} onClick={() => startGame('learning', cat)} className="p-3 rounded-lg border-2 border-gray-100 hover:border-blue-400 hover:bg-white transition-all font-medium text-gray-700 text-sm text-center shadow-sm">{cat}</button>))}
        </div>
      </div>
  );

  const renderSettings = () => (
    <div className="p-4 max-w-xl mx-auto h-full flex flex-col">
      <div className="flex items-center justify-between mb-4"><h2 className="text-lg font-bold flex items-center text-gray-800"><Settings className="mr-2"/> è¨­å®š</h2><button onClick={() => setMode('menu')} className="p-2 bg-gray-100 rounded-full hover:bg-gray-200"><X size={20}/></button></div>
      <div className="mb-4 flex-1 flex flex-col">
        <label className="block text-xs font-bold mb-1 text-gray-700">å•é¡Œãƒ‡ãƒ¼ã‚¿ (CSV)</label>
        <div className="text-xs text-gray-500 mb-2 bg-blue-50 p-2 rounded leading-tight">è‹±æ–‡[TAB]æ—¥æœ¬èª[TAB]ã‚«ãƒ†ã‚´ãƒª[TAB]è§£èª¬(çœç•¥å¯)<br/>â€»4åˆ—ç›®ã«èªå¥ã®è§£èª¬ãªã©ã‚’å…¥ã‚Œã‚‹ã¨ãƒ’ãƒ³ãƒˆ2ã§è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</div>
        <textarea value={rawCsvData} onChange={(e) => setRawCsvData(e.target.value)} className="flex-1 p-2 border border-gray-300 rounded-lg font-mono text-xs focus:ring-2 focus:ring-blue-500 outline-none resize-none"/>
      </div>
      <div className="mb-4"><label className="block text-xs font-bold mb-1 text-gray-700">åˆ¶é™æ™‚é–“(ç§’)</label><input type="number" value={maxTime} onChange={(e) => setMaxTime(Number(e.target.value))} className="p-2 border border-gray-300 rounded-lg w-24 text-center"/></div>
      <button onClick={saveSettings} className="w-full py-3 bg-blue-600 text-white rounded-xl font-bold hover:bg-blue-700 flex items-center justify-center"><Save size={18} className="mr-2"/> ä¿å­˜ã—ã¦æˆ»ã‚‹</button>
    </div>
  );

  return (
    <div className="min-h-screen bg-slate-100 text-gray-800 font-sans md:p-6 p-2 flex items-center justify-center">
      <div className="w-full max-w-3xl bg-white md:h-[650px] h-[90vh] shadow-2xl rounded-3xl overflow-hidden relative border border-gray-100 flex flex-col">
        {mode === 'menu' && renderMenu()}
        {mode === 'category_select' && renderCategorySelect()}
        {(mode === 'learning' || mode === 'trial' || mode === 'review') && renderGame()}
        {mode === 'result' && renderResult()}
        {mode === 'settings' && renderSettings()}
      </div>
    </div>
  );
};

export default App;
